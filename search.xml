<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go环境安装</title>
    <url>/go/go%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>go语言环境的安装</p>
<span id="more"></span>

<p>安装就按照官网的步骤，直接安装即可，下面主要是列举下安装后的一些问题</p>
<ul>
<li>VsCode 插件安装失败的问题</li>
</ul>
<p>proxy.golang.org 访问失败，需要设置代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://goproxy.io,direct</span><br></pre></td></tr></table></figure>

<ul>
<li>verifying module: invalid GOSUMDB: malformed verifier id</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go env -w GOSUMDB=&quot;sum.golang.org&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者关闭包验证</span></span><br><span class="line">go env -w GOSUMDB=off</span><br></pre></td></tr></table></figure>

<ul>
<li>VsCode中红线提示</li>
</ul>
<p><code>gopls was not able to find modules in your workspace.</code></p>
<p>在 *.go文件同级目录下初始化一个新的Go模块，会自动创建一个go.mod文件<br><code>main</code> 和go文件中的package一致。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod init main</span><br></pre></td></tr></table></figure>

<ul>
<li>VsCode代码自动提示</li>
</ul>
<p>在VsCode的Command Palette中输入 <code>go:install/Update Tools</code>，在弹窗中把列出来的几项都选中，然后安装</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言变量和运算符</title>
    <url>/go/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>主要介绍go语言变量，运算符等</p>
<span id="more"></span>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>变量被定义为程序运行时储存和操纵数据的实体。变量可以通过变量名访问。 变量名格式：字母数字下划线，不能以数字开头。</p>
<p>变量声明:</p>
<blockquote>
<p>var variable_name variable_type</p>
</blockquote>
<p>也可以一次声明多个变量</p>
<blockquote>
<p>var variable_name, variable_name1 variable_type</p>
</blockquote>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><ul>
<li><strong>指定变量类型，如果没有初始化，则变量默认为零值。</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println()</span><br><span class="line"><span class="comment">// 默认false</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">bool</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">// 默认 &quot;&quot; 空字符串</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="comment">// 默认0</span></span><br><span class="line"><span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">fmt.Println(i)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>第二种， 根据值自行判定变量类型</strong></li>
</ul>
<p>不需要显示声明变量类型，自动推断</p>
<blockquote>
<p>var v_name &#x3D; value</p>
</blockquote>
<p>比如:  <code>var num = 1</code></p>
<ul>
<li><strong>变量的简短声明</strong></li>
</ul>
<p><code>x := 1</code>  这个代码中， <code>x</code> 自动被声明为 int 类型，并存储了值 1 。 这种方式只能被用在函数体内。</p>
<p>如果变量已经使用 <code>var</code> 声明过了，再使用 <code>:=</code> 声明变量，就产生编译错误</p>
<ul>
<li><strong>多变量声明</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="type">int</span></span><br><span class="line">vname1, vname2, vname3 = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">fmt.Println(vname1, vname2, vname3)</span><br><span class="line"></span><br><span class="line">vname4, vname5 := <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">a, b, c := <span class="number">5</span>, <span class="number">7</span>, <span class="string">&quot;abc&quot;</span></span><br><span class="line">fmt.Println(vname4, vname5)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">       vname1 v_type1</span><br><span class="line">       vname2 v_type2</span><br><span class="line">   )</span><br></pre></td></tr></table></figure>
<h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：</p>
<p>当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 <code>i</code> 的值进行了拷贝</p>
<p>可以通过 <code>&amp;i</code> 来获取变量 <code>i</code> 的内存地址</p>
<p>如下， 可以看到， <code>i</code> 和 <code>j</code> 实际上对应的内存地址是不同的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var i = 1</span><br><span class="line">var j = i</span><br><span class="line">fmt.Println(&amp;i, &amp;j)</span><br><span class="line"># 结果</span><br><span class="line">0xc00000a0e8 0xc00000a0f0</span><br></pre></td></tr></table></figure>
<p>堆内存和栈内存：栈内存用于存储局部变量以及函数调用的信息。堆内存用于存储程序中创建的对象和实例。</p>
<p>变量的值存储在堆内。</p>
<p>更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</p>
<blockquote>
<p>位(Bit)是数据存储的最小单位，字节(Byte)常用于处理字符级数据，而字(Word)则是计算机硬件设计的基本单位，与特定计算机体系结构有关。</p>
</blockquote>
<p>一个引用类型的变量 <code>r1</code> 存储的是 <code>r1</code> 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p>
<p>这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。</p>
<p>引用类型的变量存储的是一个指向实际数据的引用。</p>
<p>当将一个引用类型的变量赋值给另一个变量时，两个变量将引用同一个数据，修改一个变量会影响到另一个变量。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>同一个变量不能被重复初始化声明 ，会提示 <code>no new variables on left side of :=</code></li>
<li>声明了局部变量没有使用，会编译报错 <code>xxx declared but not used</code></li>
<li>如果你想要交换两个变量的值，则可以简单地使用 <code>a, b = b, a</code>，两个变量的类型必须是相同</li>
<li>空白标识符 _ 也被用于抛弃值，如值 5 在：<code>_, b = 5, 7</code> 中被抛弃。</li>
<li>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</li>
<li>并行赋值也被用于当一个函数返回多个返回值时，比如这里的 <code>val</code> 和错误 <code>err</code> 是通过调用 <code>Func1</code> 函数同时得到：<code>val, err = Func1(var1)</code>。</li>
</ul>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<p>常量中的数据类型只可以是布尔型、数字型和字符串型。</p>
<p>定义格式如下</p>
<blockquote>
<p>const identifier [type] &#x3D; value</p>
</blockquote>
<p>可以省略类型说明符 <code>[type]</code>，因为编译器可以根据变量的值来推断其类型。</p>
<p>常量也可以用作枚举</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Unknown = <span class="number">0</span></span><br><span class="line">	Female  = <span class="number">1</span></span><br><span class="line">	Male    = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数字 0、1 和 2 分别代表未知性别、女性和男性。</p>
<p>常量可以用<code>len()</code>, <code>cap()</code>, <code>unsafe.Sizeof()</code>函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    b = <span class="built_in">len</span>(a)</span><br><span class="line">    c = unsafe.Sizeof(a)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言结构和基础语法</title>
    <url>/go/go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E5%92%8C%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>简单介绍下go语言的程序结构，基础语法和数据类型。</p>
<span id="more"></span>

<h1 id="结构示例"><a href="#结构示例" class="headerlink" title="结构示例"></a>结构示例</h1><p>go语言的基础组成包含以下部分</p>
<ul>
<li>包声明</li>
<li>引入包 </li>
<li>函数</li>
<li>变量</li>
<li>语句和表达式</li>
<li>注释</li>
</ul>
<p>以下面代码为例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*输出hello world*/</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>第一行代码 <code>package main</code> 定义了包名。必须在源文件中非注释的第一行指明这个文件属于哪个包，如：<code>package main</code>。<code>package main</code>表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 <code>main</code> 的包。</li>
<li>下一行 <code>import &quot;fmt&quot;</code> 告诉 Go 编译器这个程序需要使用 <code>fmt</code> 包，<code>fmt</code> 包实现了格式化 IO（输入&#x2F;输出）的函数。</li>
<li>下一行 <code>func main()</code> 是程序开始执行的函数。<code>main</code> 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 <code>init()</code> 函数则会先执行该函数）</li>
<li><code>/**/</code> 是注释。可以在任何地方使用以 <code>//</code> 开头的单行注释。多行注释也叫块注释，均已以 <code>/*</code> 开头，并以 <code>*/</code> 结尾</li>
<li><code>fmt.Println()</code> 将字符串输出到控制台</li>
<li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如<code>Print</code>，那么使用这种形式的标识符的对象就可以被外部包的代码所使用(需要先引入)，这被称为导出(像java中的public)，标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像java的<code>protected</code> ）</li>
</ol>
<h1 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h1><p>运行go文件</p>
<blockquote>
<p>go run hello.go</p>
</blockquote>
<p>也可以生成二进制文件</p>
<blockquote>
<p>go build hello.go</p>
</blockquote>
<p><code>&#123;</code> 不能单独放在一行， 和java不同。</p>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><ul>
<li>行分隔符</li>
</ul>
<p>语句结束是由分号（;）标志，但是代码不需要添加，Go编译器会自动在每行结束的地方插入分号。一行代表一个语句结束。</p>
<ul>
<li>注释</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 单行注释</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">多行注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<ul>
<li>标识符</li>
</ul>
<p>标识符用来命名变量、类型等程序实体。</p>
<p>必须是字母数字下划线组成，但是第一个字符必须是字母或者下划线，不能是数字。</p>
<ul>
<li>字符串连接</li>
</ul>
<p>字符串连接使用 <code>+</code> 操作</p>
<blockquote>
<p>fmt.Println(“hello, “ + “world”)</p>
</blockquote>
<ul>
<li>关键字</li>
</ul>
<p>有25个关键字</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">break        default      func         interface    select</span><br><span class="line">case         defer        go           map          struct</span><br><span class="line">chan         else         goto         package      switch</span><br><span class="line">const        fallthrough  if           range        type</span><br><span class="line">continue     for          import       return       var</span><br></pre></td></tr></table></figure>

<p>36个预定义标识符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">append       bool         byte         cap          close        complex      </span><br><span class="line">complex64    complex128   uint16       copy         false        float32      </span><br><span class="line">float64      imag         int          int8         int16        uint32       </span><br><span class="line">int32        int64        iota         len          make         new          </span><br><span class="line">nil          panic        print        println      real         recover      </span><br><span class="line">string       true         uint         uint8        uint64       uintptr      </span><br></pre></td></tr></table></figure>

<p>程序一般由关键字、常量、变量、运算符、类型和函数组成。</p>
<ul>
<li>空格</li>
</ul>
<p>空格通常用于分隔标识符、关键字、运算符和表达式，以提高代码的可读性。</p>
<ol>
<li>变量的声明必须使用空格隔开</li>
<li>关键字和表达式之间要使用空格</li>
</ol>
<ul>
<li>格式化字符串</li>
</ul>
<p>Go 语言中使用 <code>fmt.Sprintf</code> 或 <code>fmt.Printf</code> 格式化字符串并赋值给新串</p>
<p><code>Sprintf</code> 根据格式化参数生成格式化的字符串并返回该字符串<br><code>Printf</code>  根据格式化参数生成格式化的字符串并写入标准输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*输出hello world*/</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello, world&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello, &quot;</span> + <span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> url = <span class="string">&quot;name=%s&amp;num=%d&quot;</span></span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">	<span class="keyword">var</span> result = fmt.Sprintf(url, name, num)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">	fmt.Printf(url, name, num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据类型用于声明函数和变量。数据类型是为了把数据分成内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p>
<ol>
<li>布尔型</li>
</ol>
<p>布尔型只能是true或者false， 例如 <code>var b bool = true</code></p>
<ol start="2">
<li>数字类型</li>
</ol>
<p>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</p>
<p>还区分有符号和无符号的</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>uint8</td>
<td>无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td>uint16</td>
<td>无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td>uint32</td>
<td>无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td>uint64</td>
<td>无符号 64 位整型</td>
</tr>
<tr>
<td>int8</td>
<td>有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td>int16</td>
<td>有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td>int32</td>
<td>有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td>int64</td>
<td>有符号 64 位整型</td>
</tr>
</tbody></table>
<ol start="3">
<li>字符串类型</li>
</ol>
<p>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。使用 <code>UTF-8</code> 编码</p>
<ol start="4">
<li><p>派生类型</p>
<ul>
<li>指针类型（Pointer）</li>
<li>数组类型</li>
<li>结构化类型(struct)</li>
<li>Channel 类型</li>
<li>函数类型</li>
<li>切片类型</li>
<li>接口类型（interface）</li>
<li>Map 类型</li>
</ul>
</li>
</ol>
<p>派生类型(也称为复合类型)</p>
<ol start="5">
<li>其他数字类型</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>类似 uint8</td>
</tr>
<tr>
<td>rune</td>
<td>类似 int32</td>
</tr>
<tr>
<td>uint</td>
<td>32 或 64 位</td>
</tr>
<tr>
<td>int</td>
<td>与 uint 一样大小</td>
</tr>
<tr>
<td>uintptr</td>
<td>无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>shardingsphere分库分表</title>
    <url>/java/shardingsphere%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    <content><![CDATA[<p>主要记录使用shardingsphere-jdbc 5.2.0进行分库，分表，分库加分表，读写分离，自定义复合分片算法等的操作步骤。</p>
<span id="more"></span>

<h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="基因法"><a href="#基因法" class="headerlink" title="基因法"></a>基因法</h2><blockquote>
<p>基因法原理 : 对一个数取余2的n次方，那么余数就是这个数的二进制的最后n位数。</p>
</blockquote>
<ul>
<li>举例</li>
</ul>
<p>十进制数对10的n次幂取余，余数是10进制数的最后n位， 比如</p>
<p>11 % 10，余数 1</p>
<p>122 % 10，余数 2</p>
<p>122 % 100 , 余数 22</p>
<p>同理，对一个数取余2的n次方，余数就是这个数的二进制的最后n位数，然后可以再转为10进制。</p>
<h2 id="为什么分片数要是2的n次幂"><a href="#为什么分片数要是2的n次幂" class="headerlink" title="为什么分片数要是2的n次幂"></a>为什么分片数要是2的n次幂</h2><ul>
<li>可以将取模算法优化成性能更高的位运算算法。</li>
</ul>
<p>如： 11 % 4 等于 11 &amp; (4-1) </p>
<ul>
<li>可以将表在多个库中均匀分布。</li>
</ul>
<p>通常分表会和分库一起进行，比如需要分成2个库8个表，分表和分库的数量都是2的n次幂，可以实现均匀分布，8个表均分到2个库中，每个库4个表。</p>
<ul>
<li>第三个也是最重要的原因，可以减少扩容时迁移的数据量，只需要迁移一半。</li>
</ul>
<p>比如 原来分2个表，order_0,order_1</p>
<ol>
<li>userId % 2 &#x3D; 0 ，对应 order_0</li>
<li>userId % 2 &#x3D; 1 , 对应 order_1</li>
</ol>
<p>此时扩容到4个表</p>
<ol>
<li>userId % 4 &#x3D; 0 ，对应 order_0</li>
<li>userId % 4 &#x3D; 1 , 对应 order_1</li>
<li>userId % 4 &#x3D; 2 ，对应 order_2</li>
<li>userId % 4 &#x3D; 3 , 对应 order_3</li>
</ol>
<p>只需要迁移原来在 order_0, order_1 中，且 userId % 4 &gt;&#x3D;2 数据就行。</p>
<ol>
<li>userId % 4 &#x3D; 2的数据， 从 order_0 迁移到 order_2 </li>
<li>userId % 4 &#x3D; 3的数据， 从order_1  迁移到 order_3</li>
</ol>
<h1 id="具体配置和操作"><a href="#具体配置和操作" class="headerlink" title="具体配置和操作"></a>具体配置和操作</h1><p>以电商系统中用户的订单表为例。</p>
<p>电商系统中，常见的业务场景是通过userId查询用户的订单列表，因此使用userId作为分片键，查询时可以快速定位到数据库和表。</p>
<p>但是也会有通过订单号进行查询的情况，默认情况下，非分片键的查询，需要在所有分片上进行查询，然后对结果进行聚合，这样效率非常低，日志中sql如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Actual SQL: ds0 ::: SELECT  user_id,order_id,address_id,status  FROM t_order_0 </span><br><span class="line"> WHERE order_id = ? UNION ALL SELECT  user_id,order_id,address_id,status  FROM t_order_1 </span><br><span class="line"> WHERE order_id = ? ::: </span><br></pre></td></tr></table></figure>
<p>此时可以考虑新增一个订单号和userId的映射关系表即索引表。</p>
<h2 id="索引表法"><a href="#索引表法" class="headerlink" title="索引表法"></a>索引表法</h2><p>将订单号和userId的映射关系，单独保存到一个表中，通过订单号进行查询时，先从索引表中查询到对应的userId，然后在查询条件中加上userId，这样只需要2步就可以查询出结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> user_id <span class="keyword">from</span> order_user_relation <span class="keyword">where</span> order_id <span class="operator">=</span> xxx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_order <span class="keyword">where</span> order_id <span class="operator">=</span> xxx <span class="keyword">and</span> user_id <span class="operator">=</span> xxx;</span><br></pre></td></tr></table></figure>

<p>为了提升查询效率，可以在加上一层分布式缓存，将映射关系保存到redis中。但是这样会带来一定的问题，比如数据库和缓存的存储量增大。</p>
<h2 id="基因法自定义复合分片算法"><a href="#基因法自定义复合分片算法" class="headerlink" title="基因法自定义复合分片算法"></a>基因法自定义复合分片算法</h2><p>为了解决聚合查询或者索引表的问题，业界一般采用基因法来将分片键的信息，保存到非分片键中，比如取userId的后4位，拼接到order_id后面。</p>
<p>假设订单号的规则为 :  时间戳 + 随机数 + 用户id后四位。这样可以从订单号的后四位中截取到用户id的基因，可以定位到具体的分片位置，一次查询就可以查到对应的数据。</p>
<p>比如淘宝的订单号，后6位都是一样的，大概率也是用户id的后6位。</p>
<ul>
<li>算法实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">doSharding</span><span class="params">(Collection availableTargetNames, ComplexKeysShardingValue complexKeysShardingValue)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> availableTargetNames.size();</span><br><span class="line">        <span class="comment">// 判断分片数必须是2的整数次幂</span></span><br><span class="line">        <span class="keyword">if</span> ((count &amp; (count - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;分片数不是2的整数次幂，当前分片数 &#123;&#125;&quot;</span>, count);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;分片数量不是2的整数次幂，当前数量:&quot;</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(availableTargetNames);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//        String logicName = complexKeysShardingValue.getLogicTableName();</span></span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;availableTargetNames的值 &#123;&#125;&quot;</span>, JSON.toJSONString(availableTargetNames));</span><br><span class="line">        log.debug(<span class="string">&quot;complexKeysShardingValue &#123;&#125;&quot;</span>, JSON.toJSONString(complexKeysShardingValue));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先判断userId， 如果有userId， 则直接计算</span></span><br><span class="line">        Map&lt;String, Collection&lt;Comparable&lt;?&gt;&gt;&gt; nameAndValueMap = complexKeysShardingValue.getColumnNameAndShardingValuesMap();</span><br><span class="line">        Collection&lt;Comparable&lt;?&gt;&gt; userIdValueCollection = nameAndValueMap.get(userIdKey);</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(userIdValueCollection)) &#123;</span><br><span class="line">            userIdValueCollection.stream().findFirst().ifPresent(o -&gt; &#123;</span><br><span class="line">                <span class="type">Long</span> <span class="variable">index</span> <span class="operator">=</span> (Long) o % count;</span><br><span class="line">                log.debug(<span class="string">&quot;以userid &#123;&#125; 对 分片数&#123;&#125; 取余的结果为 &#123;&#125;&quot;</span>, o, count, index);</span><br><span class="line"><span class="comment">//                result.add(logicName + &quot;_&quot; + index);</span></span><br><span class="line">                result.add(String.valueOf(list.get(index.intValue())));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从订单号中截取用户id基因</span></span><br><span class="line">            Collection&lt;Comparable&lt;?&gt;&gt; orderIdCollection = nameAndValueMap.get(orderIdKey);</span><br><span class="line">            orderIdCollection.stream().findFirst().ifPresent(comparable -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> String.valueOf(comparable);</span><br><span class="line">                <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> orderId.substring(orderId.length() - userIdSuffixLength);</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Integer.parseInt(subString) % count;</span><br><span class="line">                log.debug(<span class="string">&quot;orderId中基因 &#123;&#125; 对 分片数&#123;&#125; 取余的结果为 &#123;&#125;&quot;</span>, subString, count, index);</span><br><span class="line"><span class="comment">//                result.add(logicName + &quot;_&quot; + index);</span></span><br><span class="line">                result.add(String.valueOf(list.get(index)));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>配置信息</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模式配置</span></span><br><span class="line"><span class="attr">spring.shardingsphere.mode.type</span>=<span class="string">Standalone</span></span><br><span class="line"><span class="attr">spring.shardingsphere.mode.repository.type</span>=<span class="string">JDBC</span></span><br><span class="line"><span class="comment"># 数据源配置 配置真实数据源</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.names</span>=<span class="string">ds0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.jdbc-url</span>=<span class="string">jdbc:mysql://localhost:3306/shop_ds_0?serverTimezone=Asia/Shanghai&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.shardingsphere.datasource.ds0.password</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 广播表规则列表</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.broadcast-tables</span>=<span class="string">t_address</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 标准分片表配置</span></span><br><span class="line"><span class="comment"># 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔，支持 inline 表达式。</span></span><br><span class="line"><span class="comment"># 缺省表示使用已知数据源与逻辑表名称生成数据节点，用于广播表（即每个库中都需要一个同样的表用于关联查询，多为字典表）或只分库不分表且所有库的表结构完全一致的情况</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.tables.t_order.actual-data-nodes</span>=<span class="string">ds0.t_order_$-&gt;&#123;0..1&#125;</span></span><br><span class="line"><span class="comment"># 复合分片，自定义策略</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.tables.t_order.table-strategy.complex.sharding-columns</span>=<span class="string">user_id,order_id</span></span><br><span class="line"><span class="comment"># 分片算法名称</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.tables.t_order.table-strategy.complex.sharding-algorithm-name</span>=<span class="string">t_order_complex_custom_algorithm</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 自定义复合分片算法</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.sharding-algorithms.t_order_complex_custom_algorithm.type</span>=<span class="string">CLASS_BASED</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.sharding-algorithms.t_order_complex_custom_algorithm.props.strategy</span>=<span class="string">complex</span></span><br><span class="line"><span class="attr">spring.shardingsphere.rules.sharding.sharding-algorithms.t_order_complex_custom_algorithm.props.algorithmClassName</span>=<span class="string">com.bsd.xxyp.sharding.config.GeneComplexKeysShardingAlgorithm</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html">大众点评订单系统分库分表实践</a></li>
<li><a href="https://community.sphere-ex.com/t/topic/674">基于Apache ShardingSphere的核心业务分库分表实践</a></li>
<li><a href="https://www.cnblogs.com/chengxy-nds/p/18108596">DIY 3 种分库分表分片算法</a></li>
<li><a href="https://mp.weixin.qq.com/s/PqXJKXCzQlMVwR4EjPpXew">实战：Springboot3+ShardingSphere5.2.1生产级分库分表实现</a></li>
<li><a href="https://mp.weixin.qq.com/s/TdCqxsBeSnugWXP_MuosdQ">聊聊分库分表后非Sharding Key查询的三种方案</a></li>
<li><a href="https://mp.weixin.qq.com/s/6sI92hEH6Sxt7nzXWDW-kA">一些补充的知识点-MySQL大表分库分表基因法</a></li>
<li><a href="https://mp.weixin.qq.com/s/3cP_emfG15qJapeQwV5gtQ">看完这一篇，ShardingSphere-jdbc 实战再也不怕了</a></li>
<li><a href="https://www.cnblogs.com/chengxy-nds/p/17513945.html">SpringBoot 2 种方式快速实现分库分表，轻松拿捏</a></li>
<li><a href="https://mp.weixin.qq.com/s/1syeeqzusxt4Z-yJff0mng">分布式数据库：如何正确选择分片键？</a></li>
</ol>
<h1 id="FAQ整理"><a href="#FAQ整理" class="headerlink" title="FAQ整理"></a>FAQ整理</h1><ol>
<li>点评的文章中，userid后4位，为什么说最大是8192个表</li>
</ol>
<p>按照上面的规范，分片数必须是2的n次幂，4位数的最大值是9999，假设分片数是 2的14次幂 16384，4位数字对16384取余的结果范围是[0, 9999], 实际计算出来需要的分片数是10000个，不是2的n次幂，不满足分片数规则。<br>所以最大只能取 8192 个</p>
<ol start="2">
<li>点评的方式和基因法的区别。</li>
</ol>
<p>点评文章中userid和orderid的取模都是用的userid的后四位，所以最大是8192个。基因法里面，通过userid计算分片是按照userid % 2^n，按照订单id计算分片 &#x3D; orderId.substring(length-4) % 2^n，<br>是使用订单号的后四位进行计算，所以userid后四位的最大分片数是16个。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>shardingsphere</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法 百度uid-generator生成的id变成负数</title>
    <url>/java/snowflake-baidu-uid-generator/</url>
    <content><![CDATA[<p>项目使用了百度的uid-generator来生成唯一ID，在2024-11-21时候，观察到部分项目生成的id变成了负数，下面分析了具体的原因以及给出了解决思路。</p>
<span id="more"></span>

<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>在 <code>2024-11-21</code> 当天，开发环境发现了部分项目生成的id变成了负数，产生了业务异常，无法入库，经过排查，发现是由于使用了百度的uid-generator进行id生成，配置不当导致的。</p>
<p>项目中同时使用了 <code>DefaultUidGenerator</code> 和 <code>CachedUidGenerator</code> 两种生成策略。但是，在初始化配置时，只针对 <code>DefaultUidGenerator</code> 进行了调整，<code>CachedUidGenerator</code> 使用的默认值。</p>
<p>查看代码，发现 CachedUidGenerator 继承自 DefaultUidGenerator，在sequence上做了调整，但是前面依然是雪花算法的策略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* +------+----------------------+----------------+-----------+</span><br><span class="line">* | sign |     delta seconds    | worker node id | sequence  |</span><br><span class="line">* +------+----------------------+----------------+-----------+</span><br><span class="line">*   1bit          28bits              22bits         13bits</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Snowflake算法描述：指定机器 &amp; 同一时刻 &amp; 某一并发序列，是唯一的。据此可生成一个64 bits的唯一ID（long）。默认采用上图字节分配方式：</p>
<ul>
<li><p>sign(1bit)<br>固定1bit符号标识，即生成的UID为正数。</p>
</li>
<li><p>delta seconds (28 bits)<br>当前时间，相对于时间基点”2016-05-20”的增量值，单位：秒，最多可支持约8.7年</p>
</li>
<li><p>worker id (22 bits)<br>机器id，最多可支持约420w次机器启动。内置实现为在启动时由数据库分配，默认分配策略为用后即弃，后续可提供复用策略。</p>
</li>
<li><p>sequence (13 bits)<br>每秒下的并发序列，13 bits可支持每秒8192个并发。</p>
</li>
</ul>
<p>在 <code>DefaultUidGenerator</code> 中有说明，默认配置是从<code>2016-05-20</code>开始，大概支持8.7年，到<code>2024-11-20 21:24:16</code></p>
<blockquote>
<p>delta seconds: The next 28 bits, represents delta seconds since a customer epoch(2016-05-20 00:00:00.000).</p>
<p>Supports about 8.7 years until to 2024-11-20 21:24:16</p>
</blockquote>
<p>CachedUidGenerator不是每次获取当前时间戳作为时间位上的数字，而是在系统启动时获取系统时间作为基础，后续在该时间上进行递增。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启动时获取当前时间</span></span><br><span class="line"><span class="built_in">this</span>.lastSecond = <span class="keyword">new</span> <span class="title class_">PaddedAtomicLong</span>(TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// fill the rest slots until to catch the cursor</span></span><br><span class="line">List&lt;Long&gt; uidList = uidProvider.provide(lastSecond.incrementAndGet());</span><br></pre></td></tr></table></figure>

<h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><h2 id="调整时间基点"><a href="#调整时间基点" class="headerlink" title="调整时间基点"></a>调整时间基点</h2><p>既然是由于初始时间 epochStr 导致的，可以考虑调整 epochStr 到接近当前时间的某个日期。</p>
<p>此时需要注意，如果想要保证生成的id长度固定为19位的话，新的日期不能距离当前时间太近，否则生成的id长度会发生变化。比如可以调整到1年前的日期，如 <code>2023-11-26</code> 。</p>
<p>生成id又会从 1 开头的数字开始，如 <code>1088488405369774084</code></p>
<p>这种方案会有一个风险，生成的id可能会和调整前生成的id一样，导致id重复。原因如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Allocate bits for UID</span></span><br><span class="line"><span class="keyword">return</span> bitsAllocator.allocate(currentSecond - epochSeconds, workerId, sequence);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">allocate</span><span class="params">(<span class="type">long</span> deltaSeconds, <span class="type">long</span> workerId, <span class="type">long</span> sequence)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (deltaSeconds &lt;&lt; timestampShift) | (workerId &lt;&lt; workerIdShift) | sequence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理论上，获取id时的时间戳和基准时间的差值(currentSecond - epochSeconds)如果一致，生成的id就会相同。</p>
<p>所以此方案可以用于临时紧急修复问题，不能长期使用。</p>
<h2 id="调整位数的划分"><a href="#调整位数的划分" class="headerlink" title="调整位数的划分"></a>调整位数的划分</h2><p>可以调整 <code>timeBits</code> 到30位，增大2位，<code>seqBits</code> 调整到11位，减少2位。 此时可以支持的时间为2^30 -1 , 大概是34年，而每秒可以生成的序列为 2^11-1&#x3D;2047个。理论上也能满足大部分系统的并发场景需要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Bits allocate */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">timeBits</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">workerBits</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="variable">seqBits</span> <span class="operator">=</span> <span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<p>调整之后，生成的id又会从一个较小的数字开始，理论上到达某个条件之后，生成的id还是有可能和历史已生成的id重复的可能，需要注意。</p>
<p>或者还可以调整 <code>workerBits</code> 的位数，默认是22位，接近420w次重启， 实际上可以按需进行取舍，考虑重复使用workId或者循环利用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在系统初始阶段，最好就要先确定好位数的划分，比如增大 timeBits ，保证系统可以支持到更长的时间。减少workerBits，调整 seqBits 等。</p>
<ul>
<li><p>为什么线上系统在11-21号的时候没有报错</p>
<p>  由于线上大部分使用的是 <code>CachedUidGenerator</code>，所以是从系统启动时刻的时间戳开始计算的，如果系统近期没有重启，<code>lastSecond</code>会小于当前时间戳，并不会溢出。</p>
</li>
<li><p>为什么使用 CachedUidGenerator 生成的id顺序不是严格一致的。</p>
<ol>
<li>由于使用了 RingBuffer，如果流量不均衡的话，不同机器上消耗的速度是不同的，可能导致某些机器上消费的速度快，lastSecond 增长的快。</li>
<li>如果服务使用了动态的扩容缩容方案，不同节点的启动时间相差也会很大，后启动的机器，lastSecond会大点，生成的id 也会偏大。</li>
</ol>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">uid-generator readme</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>snowflake</tag>
        <tag>唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>使用RateLimiter进行限流</title>
    <url>/java/%E4%BD%BF%E7%94%A8RateLimiter%E8%BF%9B%E8%A1%8C%E9%99%90%E6%B5%81/</url>
    <content><![CDATA[<p>主要介绍使用RateLimiter进行请求的限流。</p>
<span id="more"></span>


<p>场景: 和第三方对接的项目中，为对接的第三方分配一个appid，需要针对appid进行限流，限制每个appid的请求不能超过指定的qps。</p>
<h1 id="Guava-RateLimiter"><a href="#Guava-RateLimiter" class="headerlink" title="Guava RateLimiter"></a>Guava RateLimiter</h1><p><code>RateLimiter</code> 是针对单机进行限流的，但是在实际的生产环境中，服务一般是通过集群的方式进行部署。假设限制的QPS是300，集群一共5台机器，如果流量分布均衡的话，每台机器的QPS是 <code>300/5 = 60</code> 。</p>
<p>但实际上，通过轮询的方式，流量不可能做到绝对的均匀，所以可以预留一定的空间，比如每台机器的qps限制在80，这样即使某台机器的流量稍微偏高，也不太可能超过限制被拦截掉。</p>
<p>此种方式适合对限流不是很严格的情况，即使部分请求被拦截，也不影响业务。</p>
<p><code>RateLimiter.create(rate)</code> 创建指定QPS的RateLimiter。</p>
<p><code>tryAcquire()</code>  以非阻塞的方式获取令牌。</p>
<h1 id="RedissonRateLimiter"><a href="#RedissonRateLimiter" class="headerlink" title="RedissonRateLimiter"></a>RedissonRateLimiter</h1><p><code>RedissonRateLimiter</code> 是redisson中提供的分布式限流器。</p>
<p><code>getRateLimiter(String name)</code> 获取对应name的 rate limiter。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRateController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, RateLimiter&gt; rateLimiterMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 针对appid配置请求频率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApolloJsonValue(&quot;$&#123;qps.rate:&#123;&#125;&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; appIdRateMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/rate/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRateLimiter</span><span class="params">(<span class="meta">@RequestParam</span> String appId)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tryAcquire(appId);</span><br><span class="line">        log.info(<span class="string">&quot;获取限流的结果为 &#123;&#125;&quot;</span>, result);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;rate limiter&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/redisson/rate&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">redissonRateLimiter</span><span class="params">(<span class="meta">@RequestParam</span> String appId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">clientRateLimiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;limiter:&quot;</span>.concat(appId));</span><br><span class="line">        <span class="keyword">if</span> (!clientRateLimiter.isExists()) &#123;</span><br><span class="line">            clientRateLimiter.setRate(RateType.OVERALL, <span class="number">1</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> clientRateLimiter.tryAcquire();</span><br><span class="line">        log.info(<span class="string">&quot;获取限流的结果为 &#123;&#125;&quot;</span>, result);</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;rate limiter&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(String appId)</span> &#123;</span><br><span class="line">        Assert.notNull(appId, <span class="string">&quot;appId不能为空&quot;</span>);</span><br><span class="line">        <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> rateLimiterMap.computeIfAbsent(appId, s -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">&quot;初始化appid &#123;&#125; 的限流器&quot;</span>, appId);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rate</span> <span class="operator">=</span> appIdRateMap.getOrDefault(appId, <span class="number">70</span>);</span><br><span class="line">            <span class="keyword">return</span> RateLimiter.create(rate);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> rateLimiter.tryAcquire();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>RateLimiter</tag>
      </tags>
  </entry>
  <entry>
    <title>python-venv虚拟环境</title>
    <url>/python/python-venv%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>在开发Python应用程序的时候，系统安装的Python3只有一个版本：3.12。所有第三方的包都会被pip安装到Python3的site-packages目录下。</p>
<p>有时候，不同的应用需要不同的版本。venv就是用来为一个应用创建一套“隔离”的Python运行环境。</p>
<span id="more"></span>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-web开发</title>
    <url>/python/python-web%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>C&#x2F;S架构，B&#x2F;S架构，web开发主要指B&#x2F;S架构。</p>
<span id="more"></span>

<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>每个HTTP请求和响应都遵循相同的格式，一个HTTP包含Header和Body两部分，其中Body是可选的。</p>
<p>HTTP协议是一种文本协议，所以，它的格式也非常简单。HTTP GET请求的格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br></pre></td></tr></table></figure>
<p>每个Header一行一个，换行符是<code>\r\n</code></p>
<p>HTTP POST请求的格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /path HTTP/1.1</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></table></figure>
<p>当遇到连续两个<code>\r\n</code>时，Header部分结束，后面的数据全部是Body</p>
<p>HTTP响应的格式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">200 OK</span><br><span class="line">Header1: Value1</span><br><span class="line">Header2: Value2</span><br><span class="line">Header3: Value3</span><br><span class="line"></span><br><span class="line">body data goes here...</span><br></pre></td></tr></table></figure>

<p>HTTP响应如果包含body，也是通过<code>\r\n\r\n</code>来分隔的。Body的数据类型由<code>Content-Type</code>头来确定，如果是网页，Body就是文本，如果是图片，Body就是图片的二进制数据</p>
<p>看到<code>Content-Encoding: gzip</code>时，需要将Body数据先解压缩，才能得到真正的数据。压缩的目的在于减少Body的大小，加快网络传输。</p>
<h1 id="WSGI接口"><a href="#WSGI接口" class="headerlink" title="WSGI接口"></a>WSGI接口</h1><p>WSGI：Web Server Gateway Interface, 用于处理http内容的响应。</p>
<p>WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">    start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>上面的<code>application()</code>函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数</p>
<ul>
<li>environ：一个包含所有HTTP请求信息的<code>dict</code>对象</li>
<li>start_response：一个发送HTTP响应的函数</li>
</ul>
<p>在<code>application()</code>函数中，调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br></pre></td></tr></table></figure>
<p>就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次<code>start_response()</code>函数。<code>start_response()</code>函数接收两个参数，一个是HTTP响应码，一个是一组<code>list</code>表示的HTTP Header，每个Header用一个包含两个<code>str</code>的<code>tuple</code>表示。</p>
<p>通常情况下，都应该把<code>Content-Type</code>头发送给浏览器。其他很多常用的HTTP Header也应该发送。</p>
<p>然后，函数的返回值<code>b&#39;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#39;</code>将作为HTTP响应的Body发送给浏览器。</p>
<p>有了WSGI，我们关心的就是如何从<code>environ</code>这个<code>dict</code>对象拿到HTTP请求信息，然后构造HTML，通过<code>start_response()</code>发送Header，最后返回Body。</p>
<p>整个<code>application()</code>函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。</p>
<p><code>application()</code>函数必须由WSGI服务器来调用。可以选择符合WSGI规范的服务器。</p>
<p>Python内置了一个WSGI服务器，这个模块叫<code>wsgiref</code>，它是用纯Python编写的WSGI服务器的参考实现，仅用于开发和测试使用。</p>
<h2 id="运行WSGI服务"><a href="#运行WSGI服务" class="headerlink" title="运行WSGI服务"></a>运行WSGI服务</h2><p>先编写 <code>hello.py</code>, 实现Web应用程序的WSGI处理函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">application</span>(<span class="params">environ, start_response</span>):</span><br><span class="line">    start_response(<span class="string">&#x27;200 OK&#x27;</span>, [(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html&#x27;</span>)])</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">b&#x27;&lt;h1&gt;Hello, web!&lt;/h1&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>再编写一个<code>server.py</code>，负责启动WSGI服务器，加载<code>application()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.py</span></span><br><span class="line"><span class="comment"># 从wsgiref模块导入:</span></span><br><span class="line"><span class="keyword">from</span> wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"><span class="comment"># 导入我们自己编写的application函数:</span></span><br><span class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> application</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个服务器，IP地址为空，端口是8000，处理函数是application:</span></span><br><span class="line">httpd = make_server(<span class="string">&#x27;&#x27;</span>, <span class="number">8000</span>, application)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Serving HTTP on port 8000...&#x27;</span>)</span><br><span class="line"><span class="comment"># 开始监听HTTP请求:</span></span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>

<p>无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过<code>environ</code>获得，HTTP响应的输出都可以通过<code>start_response()</code>加上函数返回值作为Body。</p>
<h1 id="使用Web框架"><a href="#使用Web框架" class="headerlink" title="使用Web框架"></a>使用Web框架</h1><p>一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。但是如果url数量过多，代码就很复杂了，所以可以使用web框架。比如轻量级的Flask和功能强大的Django</p>
<p>下面用Flask进行演示。</p>
<p>编写一个<code>app.py</code> 处理3个url</p>
<ol>
<li><code>GET /</code>， 首页</li>
<li><code>GET /signin</code>，登录页面，返回登录表单</li>
<li><code>POST /login</code>， 处理登录请求</li>
</ol>
<p>Flask通过Python的装饰器在内部自动地把URL和函数给关联起来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h1&gt;Hello&lt;/H1&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/signin&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signin_form</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;&#x27;&lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input name=&quot;username&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot;&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;p&gt;&lt;button type=&quot;submit&quot;&gt;Sign In&lt;/button&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="comment"># 需要从request对象读取表单内容：</span></span><br><span class="line">    <span class="keyword">if</span> request.form[<span class="string">&#x27;username&#x27;</span>] == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> request.form[<span class="string">&#x27;password&#x27;</span>] == <span class="string">&#x27;admin&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&lt;h2&gt;login success&lt;/h2&gt;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&lt;h2&gt;用户名或密码错误&lt;/h2&gt;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>在编写URL处理函数时，除了配置URL外，从HTTP请求拿到用户数据也是非常重要的。Web框架都提供了自己的API来实现这些功能。Flask通过<code>request.form[&#39;name&#39;]</code>来获取表单的内容。</p>
<h1 id="使用模板"><a href="#使用模板" class="headerlink" title="使用模板"></a>使用模板</h1><p>Web框架把我们从WSGI中拯救出来了。现在，我们只需要不断地编写函数，带上URL，就可以继续Web App的开发了。</p>
<p>Web App不仅仅是处理逻辑，展示给用户的页面也非常重要。在Python代码里拼字符串是不现实的，所以，模板技术出现了。</p>
<p>使用模板，我们需要预先准备一个HTML文档，这个HTML文档不是普通的HTML，而是嵌入了一些变量和指令，然后，根据我们传入的数据，替换后，得到最终的HTML，发送给用户</p>
<p>变量名比如 <code>&#123;&#123;name&#125;&#125;</code></p>
<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</p>
<p>Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</p>
<p>包含变量<code>&#123;&#123; name &#125;&#125;</code>的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</p>
<p>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</p>
<p>Model可以是一个 <code>dict</code></p>
<p>因为Python支持关键字参数，很多Web框架允许传入关键字参数，然后，在框架内部组装出一个<code>dict</code>作为Model。</p>
<p>Flask通过<code>render_template()</code>函数来实现模板的渲染。和Web框架类似，Python的模板也有很多种。Flask默认支持的模板是<code>jinja2</code>，所以我们先直接安装<code>jinja2</code>：</p>
<p>可以把上面输出html字符串的改为使用模板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">home</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;home.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录页面</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/signin&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">signin</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;form.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    name = request.form[<span class="string">&#x27;username&#x27;</span>]</span><br><span class="line">    pwd = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> pwd == <span class="string">&#x27;password&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;success.html&#x27;</span>, username = name)</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;form.html&#x27;</span>, message = <span class="string">&#x27;用户名或密码错误&#x27;</span>, username = name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p><strong>首页</strong>  <code>home.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>表单页</strong> <code>form.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        &#123;% if message %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">legend</span>&gt;</span>请登录:<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123; username &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>成功页</strong> <code>success.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Welcome, &#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome, &#123;&#123; username &#125;&#125;!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% for i in range(pageSize) %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/page/&#123;&#123; i &#125;&#125;&quot;</span>&gt;</span>第&#123;&#123; i + 1 &#125;&#125;页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">共 &#123;&#123;pageSize&#125;&#125; 页</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在<code>form.html</code>中加了一点条件判断，把<code>form.html</code>重用为登录失败的模板</p>
<p>一定要把模板放到正确的<code>templates</code>目录下，<code>templates</code>和<code>app.py</code>在同级目录下</p>
<p>通过MVC，我们在Python代码中处理M：Model和C：Controller，而V：View是通过模板处理的，这样，我们就成功地把Python代码和HTML代码最大限度地分离了。</p>
<p>使用模板的另一大好处是，模板改起来很方便，而且，改完保存后，刷新浏览器就能看到最新的效果。</p>
<p>在Jinja2模板中，我们用<code>&#123;&#123; name &#125;&#125;</code>表示一个需要替换的变量。很多时候，还需要循环、条件判断等指令语句，在Jinja2中，用<code>&#123;% ... %&#125;</code>表示指令</p>
<p>有了MVC，我们就分离了Python代码和HTML代码。HTML代码全部放到模板里，写起来更有效率。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数</title>
    <url>/python/python%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>主要介绍python中函数的定义，调用， python的内置函数等。</p>
<span id="more"></span>

<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><p>python中有许多内置函数 <a href="https://docs.python.org/3/library/functions.html">Built-in Functions</a></p>
<p>调用函数时，传入的参数数量不对 或者 参数数据类型不对， 都会报错。</p>
<p>内置函数还包含数据类型转换的函数</p>
<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><p>定义函数需要使用<code>def</code> 语句，后面依次写出函数名，括号，括号中的参数和冒号: ， 在缩进块中写函数体，返回值使用 <code>return</code> 返回</p>
<p>在Python交互环境中定义函数时，注意Python会出现…的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def func1(x):</span></span><br><span class="line">...   print(x)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>空函数</strong></p>
<p>函数体使用 <code>pass</code> 语句，说明什么也不做。</p>
<p>可以用来做占位符，方便后续再补充函数体的内容。</p>
<p><strong>参数检查</strong></p>
<p>函数中可以使用参数检查函数 <code>isinstance</code> 来确保参数类型的准确性。</p>
<p><strong>返回多个值</strong></p>
<p>返回多个值，实际上返回的是一个tuple， 多个变量可以同时接收一个tuple，按位置赋给对应的值。</p>
<h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p><strong>位置参数</strong></p>
<p>比如函数 <code>fun(x,y)</code>, 这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋值给 <code>x</code> 和 <code>y</code></p>
<p><strong>默认参数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def power(x, n=2):</span><br><span class="line">    s = 1</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n = n - 1</span><br><span class="line">        s = s * x</span><br><span class="line">    return s</span><br></pre></td></tr></table></figure>

<p>默认参数注意事项：</p>
<ol>
<li>必选参数在前，默认参数在后</li>
<li>变化大的参数在前，变化小的参数在后，变化小的可以作为默认参数。</li>
<li>默认参数可以用来兼容旧的函数，避免修改后其他调用的地方报错。</li>
<li>默认参数可以降低调用函数的难度。</li>
<li>默认参数的坑 <strong>默认参数必须指向不变的对象</strong></li>
</ol>
<p><strong>可变参数</strong></p>
<p>在参数前面加一个 <code>*</code> 号， 在函数内部，参数接收到的是一个tuple</p>
<p>Python允许你在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去。</p>
<p><strong>关键字参数</strong></p>
<p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p>
<p>关键字参数， 可以扩展函数的功能，比如注册功能，将一些可选项，通过关键字参数传入进去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def person(name, age, **kw):</span><br><span class="line">    print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)</span><br></pre></td></tr></table></figure>
<p>函数除了接受必选参数外，还可以接受关键字参数 <code>kw</code>, 调用函数时， 可以传入任意个数的关键字参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Michael&#x27;</span>, 30)</span></span><br><span class="line">name: Michael age: 30 other: &#123;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Bob&#x27;</span>, 35, city=<span class="string">&#x27;Beijing&#x27;</span>)</span></span><br><span class="line">name: Bob age: 35 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Adam&#x27;</span>, 45, gender=<span class="string">&#x27;M&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span></span><br><span class="line">name: Adam age: 45 other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>也可以先组装一个dict， 把dict作为关键字参数传递进去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; extra = &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;Engineer&#x27;</span>&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Jack&#x27;</span>, 24, **extra)</span></span><br><span class="line">name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p><code>**extra</code> 表示将<code>extra</code>这个dict的所有key-value用关键字参数传入到函数的<code>**kw</code>, <code>kw</code>将获得一个dict，是<code>extra</code>的一份拷贝，对<code>kw</code>的改动将不影响<code>extra</code>里面的数据。</p>
<p><strong>命名关键字参数</strong></p>
<p>对于关键字参数，函数调用者可以传入任意不受限制的关键字参数，如果要检查传入了哪些，就需要在函数内部通过 <code>kw</code> 进行检查，但是调用者依然可以传入任意参数。</p>
<p>如果要限制关键字参数的参数名，可以使用命名关键字参数。比如只接收<code>city</code>和<code>job</code>作为关键字参数，方式如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def person(name, age, *, city, job):</span><br><span class="line">    print(name, age, city, job)</span><br></pre></td></tr></table></figure>
<p>命名关键字参数需要一个特殊的分隔符 <code>*</code>, <code>*</code> 后面的参数被视为命名关键字参数。</p>
<p>调用方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Jack&#x27;</span>, 24, city=<span class="string">&#x27;Beijing&#x27;</span>, job=<span class="string">&#x27;Engineer&#x27;</span>)</span></span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure>
<p>两个参数必须都要传入， 否则就会报错</p>
<blockquote>
<p>TypeError: person1() missing 1 required keyword-only argument: ‘job’</p>
</blockquote>
<p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def person(name, age, *args, city, job):</span><br><span class="line">    print(name, age, args, city, job)</span><br></pre></td></tr></table></figure>
<p>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Jack&#x27;</span>, 24, <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: person() missing 2 required keyword-only arguments: &#x27;city&#x27; and &#x27;job&#x27;</span><br></pre></td></tr></table></figure>

<p>由于调用时缺少参数名<code>city</code>和<code>job</code>，Python解释器把前两个参数视为位置参数，后两个参数传给<code>*args</code>，但缺少命名关键字参数导致报错。</p>
<p>命名关键字参数也可以有缺省值，从而简化调用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def person(name, age, *, city=&#x27;Beijing&#x27;, job):</span><br><span class="line">    print(name, age, city, job)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; person(<span class="string">&#x27;Jack&#x27;</span>, 24, job=<span class="string">&#x27;Engineer&#x27;</span>)</span></span><br><span class="line">Jack 24 Beijing Engineer</span><br></pre></td></tr></table></figure>

<p>使用命名关键字参数时，如果没有可变参数，就必须加上分隔符<code>*</code> ， 如果缺少<code>*</code>，会被当做位置参数处理。</p>
<p><strong>参数组合</strong></p>
<p>可以使用上面几种参数类型进行组合，但是顺序要保证是： 必选参数，默认参数，可变参数，关键字参数和命名关键字参数。</p>
<p>通过一个<code>tuple</code> 和 <code>dict</code> 可以调用任意函数。<code>func(*args, **kw)</code></p>
<p><strong>总结</strong></p>
<ol>
<li>默认参数一定要用不可变参数， 否则会有逻辑错误</li>
<li><code>*args</code> 是可变参数， 接收的是一个tuple</li>
<li><code>**kw</code> 是关键字参数， 接收的是一个dict</li>
<li><code>*args</code> 和 <code>**kw</code> 是python的习惯写法， 最好使用习惯写法</li>
<li>注意调用可变参数和关键字参数时候的传值方式。</li>
</ol>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>使用递归函数要防止栈溢出。 函数调用是通过栈<code>stack</code> 这种数据结构实现的。</p>
<p>解决递归调用栈溢出的方式是使用<code>尾递归</code> 优化，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python函数式编程</title>
    <url>/python/python%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>我们通过把大段的代码拆分成函数，通过一层层的函数调用，来把复杂的任务分解成简单的任务，这种分解可以称为面向过程的程序设计。</p>
<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。</p>
<span id="more"></span>

<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>变量名可以指向函数，函数名其实就是指向函数的一个变量。</p>
<p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<h2 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map&#x2F;reduce"></a>map&#x2F;reduce</h2><blockquote>
<p>MapReduce 的原理在于将大规模的数据处理任务划分为多个并行的 Map 和 Reduce 操作，充分利用了集群中的计算资源，实现了高效的分布式计算。通过将数据处理过程分解为 Map 和 Reduce 两个阶段，并在其中引入数据的分组和排序操作，MapReduce 能够有效地处理大规模数据集，并具备容错性和可扩展性。</p>
</blockquote>
<p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p>
<p>比如将一个整数集合转换为字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L=[1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = map(str, L)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; list(r)</span></span><br><span class="line">[&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;]</span><br></pre></td></tr></table></figure>

<p><code>map()</code> 作为高阶函数，把运算规则抽象化了。</p>
<p><code>reduce</code> 把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上, 这个函数必须接收两个参数，<code>reduce</code>把<strong>结果</strong>继续和序列的下一个元素做累积计算，其效果就是</p>
<blockquote>
<p>reduce(f, [x1, x2, x3, x4]) &#x3D; f(f(f(x1, x2), x3), x4)</p>
</blockquote>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter()</code> 函数用于过滤序列。</p>
<p><code>filter()</code>也接收一个函数和一个序列。<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<p>filter的关键在于正确实现一个筛选函数。</p>
<h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>内置的<code>sorted()</code>函数可以对list进行排序。默认按照升序排列。</p>
<p><code>sorted()</code>函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序, key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。</p>
<p><code>sorted()</code>对字符串排序，是按照ASCII的大小比较的, 可以使用<code>ord()</code>函数将字母转为数字来查看大小。由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母Z会排在小写字母a的前面。</p>
<p>反向排序，可以传入第三个参数 <code>reverse=True</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sorted([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=str.lower, reverse=True)</span></span><br><span class="line">[&#x27;Zoo&#x27;, &#x27;Credit&#x27;, &#x27;bob&#x27;, &#x27;about&#x27;]</span><br></pre></td></tr></table></figure>

<h1 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h1><p>高阶函数可以把函数作为结果返回，不是直接返回的值，调用函数时，返回的是函数，只有当再次调用返回函数时，才会进行计算。例如 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def lazy_sum(*args):</span><br><span class="line">    def sum():</span><br><span class="line">        ax = 0</span><br><span class="line">        for n in args:</span><br><span class="line">            ax = ax + n</span><br><span class="line">        return ax</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>

<p>在函数 <code>lazy_sum</code>中又定义了函数<code>sum</code>，内部函数可以引用外部函数的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为 “闭包(Closure)”</p>
<p>每次调用 <code>lazy_sum()</code>时，返回的是一个新的函数，两次调用的结果不相等。</p>
<p><strong>闭包</strong></p>
<blockquote>
<p> 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</p>
</blockquote>
<p><strong>nonlocal</strong></p>
<p>使用闭包时，内层函数引用了外层函数的局部变量，读取时没问题，如果修改，会报错</p>
<blockquote>
<p>UnboundLocalError: cannot access local variable ‘x’ where it is not associated with a value</p>
</blockquote>
<p>例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def inc():</span><br><span class="line">    x = 0</span><br><span class="line">    def fn():</span><br><span class="line">        # nonlocal x</span><br><span class="line">        x = x + 1</span><br><span class="line">        return x</span><br><span class="line">    return fn</span><br><span class="line"></span><br><span class="line">f = inc()</span><br><span class="line">print(f()) # 1</span><br><span class="line">print(f()) # 2</span><br></pre></td></tr></table></figure>
<p>原因是 <code>x</code> 作为局部变量没有初始化，需要在fn函数内部加上一个 <code>nonlocal x</code> 的声明，加上后，解释器会把<code>fn()</code>内部的 <code>x</code> 看做外层函数的局部变量。</p>
<blockquote>
<p> 使用闭包时，对外层变量赋值前，需要先使用nonlocal声明该变量不是当前函数的局部变量。</p>
</blockquote>
<h1 id="匿名函数lambda"><a href="#匿名函数lambda" class="headerlink" title="匿名函数lambda"></a>匿名函数lambda</h1><p>我们在传入函数时，有时候不需要显示的定义函数，直接传入匿名函数更方便。例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))</span><br></pre></td></tr></table></figure>
<p>匿名函数 <code>lambda x: x * x</code> 实际上就是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def f(x):</span><br><span class="line">    return x * x</span><br></pre></td></tr></table></figure>
<p>关键字 <code>lambda</code> 表示匿名函数，冒号前面的 <code>x</code> 表示参数。匿名函数只能有一个表达式，不用return， 返回值就是表达式的结果。</p>
<p>匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f = lambda x : x + x</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f</span></span><br><span class="line">&lt;function &lt;lambda&gt; at 0x000001A9659FA160&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f(5)</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>也可以把匿名函数作为返回值返回</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def build(x, y):</span><br><span class="line">    return lambda: x * x + y * y</span><br></pre></td></tr></table></figure>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>由于函数是一个对象，函数可以赋值给一个变量，通过变量也能调用该函数。函数对象有一个 <code>__name__</code> 属性，可以拿到函数名。</p>
<p>假设要增加函数的功能，不修改函数的定义，这种在代码运行期间动态增加功能的方式，称为 “装饰器”(Decorator)。 类似java的 <code>AOP</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def log(func):</span><br><span class="line">    # @functools.wraps(func)</span><br><span class="line">    def wrapper(*args, **kw):</span><br><span class="line">        print(&#x27;call function %s&#x27; % func.__name__)</span><br><span class="line">        return func(*args, **kw)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@log</span><br><span class="line">def now():</span><br><span class="line">    print(&#x27;2023-11-01&#x27;)</span><br><span class="line"></span><br><span class="line">now()</span><br></pre></td></tr></table></figure>

<p>把<code>@log</code> 放到 <code>now()</code>函数的定义处，相当于执行了</p>
<blockquote>
<p>now &#x3D; log(now)</p>
</blockquote>
<p>原来的<code>now</code>函数依然存在，只是现在的 <code>now</code> 指向了新的函数。就是 <code>log</code> 中返回的 <code>wrapper</code> 函数。</p>
<p>如果decorator本身需要传入参数，就需要再包一层函数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def log(text):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        # @functools.wraps(func)</span><br><span class="line">        def wrapper(*args, **kw):</span><br><span class="line">            print(&#x27;%s %s()&#x27; % (text, func.__name__))</span><br><span class="line">            return func(*args, **kw)</span><br><span class="line">        </span><br><span class="line">        return wrapper</span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@log(&#x27;执行了&#x27;)</span><br><span class="line">def now():</span><br><span class="line">    print(&#x27;2023-11-01&#x27;)</span><br><span class="line"></span><br><span class="line">now()</span><br></pre></td></tr></table></figure>

<p>上面的2种写法，会导致调用函数时，返回的<code>__name__</code> 发生变化，因为实际上函数名已经指向新的函数了。所以需要把原始函数的<code>__name__</code>等属性赋值给新函数， 否则有些依赖函数签名的代码会执行错误。</p>
<p>使用内置的 <code>functools.wraps</code> 来进行处理。 如上面代码块中注释掉的部分。</p>
<h1 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h1><p><code>functools</code> 模块提供了很多功能， 其中一个就是偏函数(Partial function)</p>
<p>函数通过设定参数的默认值，可以降低调用难度，偏函数也可以做到，比如 <code>int()</code>类型转换</p>
<p><strong>偏函数就是将某些参数固定住，简化调用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int(<span class="string">&#x27;1111&#x27;</span>)</span></span><br><span class="line">1111</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int(<span class="string">&#x27;1111&#x27;</span>, base=2)</span></span><br><span class="line">15</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int(<span class="string">&#x27;1111&#x27;</span>, base=16)</span></span><br><span class="line">4369</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int(<span class="string">&#x27;1111&#x27;</span>, base=8)</span></span><br><span class="line">585</span><br></pre></td></tr></table></figure>

<p>假设我们需要做大量的二进制转换，每次传入 <code>base=2</code>会很麻烦， 可以定义一个 int2() 函数， 默认把<code>base=2</code> 传入进去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def int2(x, base=2):</span><br><span class="line">    return int(x, base)</span><br></pre></td></tr></table></figure>

<p><code>functools.partial</code>就是帮助我们创建一个偏函数，不需要自己定义 <code>int2()</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import functools</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8=functools.partial(int, base=8)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8(<span class="string">&#x27;1111&#x27;</span>)</span></span><br><span class="line">585</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8(<span class="string">&#x27;111100&#x27;</span>)</span></span><br><span class="line">37440</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8(<span class="string">&#x27;11001&#x27;</span>)</span></span><br><span class="line">4609</span><br></pre></td></tr></table></figure>

<p>所以<code>functools.partial</code>的作用就是， 把一个函数的某些参数固定住(设置默认值)， 返回一个新函数，调用新函数会更简单。</p>
<p>新函数仅仅是把参数设置了默认值，但是调用的时候依然可以传入其他的值.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; int8(<span class="string">&#x27;1111&#x27;</span>,  base=10)</span></span><br><span class="line">1111</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建偏函数时，实际上可以接收函数对象、<code>*args</code>和<code>**kw</code>这3个参数<br>当传入</p>
<blockquote>
<p>max2 &#x3D; functools.partial(max, 10)</p>
</blockquote>
<p>实际上会把<code>10</code>作为<code>*args</code>的一部分自动加到左边</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">max2(5, 6, 7)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相当于:</span></span><br><span class="line">args = (10, 5, 6, 7)</span><br><span class="line">max(*args)</span><br></pre></td></tr></table></figure>
<p>实际的结果是 <code>10</code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python图形界面</title>
    <url>/python/python%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<p>主要介绍图形界面的操作。包括Tkinter和海龟绘图。</p>
<span id="more"></span>

<h1 id="Tkinter"><a href="#Tkinter" class="headerlink" title="Tkinter"></a>Tkinter</h1><p>Python支持多种图形界面的第三方库，包括</p>
<ul>
<li>Tk</li>
<li>wxWidgets</li>
<li>Qt</li>
<li>GTK</li>
</ul>
<p>等等。</p>
<p>Python自带的库是支持Tk的Tkinter，使用Tkinter，无需安装任何包，就可以直接使用。</p>
<p>我们编写的Python代码会调用内置的Tkinter，Tkinter封装了访问Tk的接口；</p>
<p>Tk是一个图形库，支持多个操作系统，使用Tcl语言开发；</p>
<p>Tk会调用操作系统提供的本地GUI接口，完成最终的GUI。</p>
<p>所以，我们的代码只需要调用Tkinter提供的接口就可以了。</p>
<p>使用Tkinter，第一步是导入Tkinter包的所有内容</p>
<blockquote>
<p>from tkinter import *</p>
</blockquote>
<p>第二步是从<code>Frame</code>派生一个<code>Application</code>类，这是所有Widget的父容器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span>(<span class="title class_ inherited__">Frame</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, master=<span class="literal">None</span></span>):</span><br><span class="line">        Frame.__init__(self, master)</span><br><span class="line">        self.pack()</span><br><span class="line">        self.createWidgets()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">createWidgets</span>(<span class="params">self</span>):</span><br><span class="line">        self.helloLabel = Label(self, text=<span class="string">&#x27;这是gui界面的内容&#x27;</span>)</span><br><span class="line">        self.helloLabel.pack()</span><br><span class="line">        self.inputText = Entry(self)</span><br><span class="line">        self.inputText.pack()</span><br><span class="line">        self.submitBtn = Button(self, text=<span class="string">&#x27;提交&#x27;</span>, command=self.hello)</span><br><span class="line">        self.submitBtn.pack()</span><br><span class="line">        self.quitButton = Button(self, text=<span class="string">&#x27;退出&#x27;</span>, command=self.quit)</span><br><span class="line">        self.quitButton.pack()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        info = self.inputText.get() <span class="keyword">or</span> <span class="string">&#x27;你好&#x27;</span></span><br><span class="line">        messagebox.showinfo(<span class="string">&#x27;弹窗&#x27;</span>, <span class="string">&#x27;Hello, %s&#x27;</span> % info)</span><br></pre></td></tr></table></figure>

<p>在GUI中，每个Button、Label、输入框等，都是一个Widget。Frame则是可以容纳其他Widget的Widget，所有的Widget组合起来就是一棵树。</p>
<p>pack()方法把Widget加入到父容器中，并实现布局。pack()是最简单的布局，grid()可以实现更复杂的布局。</p>
<p>在<code>createWidgets()</code>方法中，我们创建一个Label和一个Button，当Button被点击时，触发<code>self.quit()</code>使程序退出。</p>
<p>第三步，实例化Application，并启动消息循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app = Application()</span><br><span class="line"><span class="comment"># 设置窗口标题:</span></span><br><span class="line">app.master.title(<span class="string">&#x27;gui界面&#x27;</span>)</span><br><span class="line"><span class="comment"># 主消息循环:</span></span><br><span class="line">app.mainloop()</span><br></pre></td></tr></table></figure>

<p>GUI程序的主线程负责监听来自操作系统的消息，并依次处理每一条消息。因此，如果消息处理非常耗时，就需要在新线程中处理。</p>
<h1 id="海龟绘图"><a href="#海龟绘图" class="headerlink" title="海龟绘图"></a>海龟绘图</h1><p>在1966年，Seymour Papert和Wally Feurzig发明了一种专门给儿童学习编程的语言——LOGO语言，它的特色就是通过编程指挥一个小海龟（turtle）在屏幕上绘图。</p>
<p>海龟绘图（Turtle Graphics）后来被移植到各种高级语言中，Python内置了turtle库，基本上100%复制了原始的Turtle Graphics的所有功能。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/python/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>python输入输出，基础数据类型和变量。</p>
<span id="more"></span>

<h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><ul>
<li><p>输入</p>
<blockquote>
<p>name &#x3D; input(‘请输入xx’)</p>
</blockquote>
</li>
<li><p>输出</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;hello aa&#x27;</span>)</span></span><br><span class="line">hello aa</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;haha&#x27;</span>)</span></span><br><span class="line">hello 张三 haha</span><br></pre></td></tr></table></figure>
<p><code>print()</code> 输出时，遇到逗号 <code>,</code> 会转换成空格</p>
<h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul>
<li><strong>整数</strong></li>
</ul>
<p>十六进制，使用 <code>0x</code> 开头</p>
<p>比较大的数，允许使用下划线 <code>_</code> 进行分隔，如 <code>10_000_000_000</code></p>
<ul>
<li><strong>浮点数</strong></li>
</ul>
<p>浮点数可以用数学写法，比如 <code>1.231</code>, 比较大的浮点数需要用科学计数法，把10用e替代， 比如 1.23x10^9，就是<code>1.23e9</code></p>
<ul>
<li><strong>字符串</strong></li>
</ul>
<p>字符串用单引号 <code>&#39;</code> 或者 双引号 <code>&quot;</code> 括起来，转义使用 <code>\</code> ，如果字符串里面有多个字符需要转义，可以使用 <code>r&#39;&#39;</code> ，表示<code>&#39;&#39;</code> 里面的字符串不转义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(r<span class="string">&#x27;\r\n\t\r\n\t&#x27;</span>)</span></span><br><span class="line">\r\n\t\r\n\t</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>字符串转数字， int(123)</p>
<ul>
<li><strong>布尔值</strong></li>
</ul>
<p>使用 <code>True</code> 和 <code>False</code> 表示，注意大小写。</p>
<p>布尔值可以使用 <code>and</code> <code>or</code> 和 <code>not</code> 进行运算。 <code>and</code>是与运算，<code>or</code>是或运算，<code>not</code>是非运算，单目运算，取反。</p>
<ul>
<li><strong>空值</strong></li>
</ul>
<p>空值使用 <code>None</code> 表示， 空值是一种特殊值。</p>
<ul>
<li><strong>变量</strong></li>
</ul>
<p>变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头，和 java 一样</p>
<p>在Python中，等号<code>=</code>是赋值语句，动态语言，同一个变量可以多次赋值，也可以赋不同类型的值。</p>
<p>变量的指向:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = <span class="string">&#x27;ABC&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b = a</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; a = <span class="string">&#x27;XYZ&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(b)</span></span><br><span class="line">ABC</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>内存中创建了 <code>ABC</code> 字符串</li>
<li>内存中创建了名为 <code>a</code>的变量，并把它指向了 <code>ABC</code></li>
<li>创建了<code>b</code>，并把<code>b</code>指向了<code>a</code>所指向的数据<code>ABC</code></li>
<li>重新把 <code>a</code> 指向了 <code>XYZ</code></li>
</ol>
<ul>
<li><strong>常量</strong></li>
</ul>
<p>用全部大写的变量名表示常量</p>
<p>除法 分为 <code>/</code> 和 <code>//</code> 地板除， <code>/</code>结果是浮点数，即使能够整除，结果也是浮点数，<code>//</code> 结果是整数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 10/3</span></span><br><span class="line">3.3333333333333335</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 9/3</span></span><br><span class="line">3.0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; 10//3</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串和编码"><a href="#字符串和编码" class="headerlink" title="字符串和编码"></a>字符串和编码</h2><p>一个字节(byte)使用8位(bit)， <code>UTF-8</code> 变长编码。</p>
<p>python的字符串类型是 <code>str</code>， 在内存中以Unicode表示，一个字符对应若干个字节。</p>
<p>对 <code>bytes</code>类型的数据，使用 <code>b</code>前缀的单引号或者双引号表示。</p>
<p>对单个字符的编码，<code>ord()</code> 函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ord(<span class="string">&#x27;a&#x27;</span>)</span></span><br><span class="line">97</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; ord(<span class="string">&#x27;人&#x27;</span>)</span></span><br><span class="line">20154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chr(78)</span></span><br><span class="line">&#x27;N&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;\u4e2d\u6587&#x27;</span></span></span><br><span class="line">&#x27;中文&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以 <code>Unicode</code>表示的 <code>str</code> 可以使用 <code>encode()</code>函数编码为指定的 <code>bytes</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abc&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span></span><br><span class="line">b&#x27;abc&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abc&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span></span><br><span class="line">b&#x27;abc&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span></span><br><span class="line">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abc12&#x27;</span>.encode(<span class="string">&#x27;ascii&#x27;</span>)</span></span><br><span class="line">b&#x27;abc12&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>相反， 从网络或者磁盘上读取到的字节流就是<code>bytes</code>，可以使用 <code>decode()</code> 方法转换为 <code>str</code></p>
<p><code>len()</code> 函数可以计算 <code>str</code>的字符数，也可以计算 <code>bytes</code> 的字节数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>)</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; len(<span class="string">&#x27;abc&#x27;</span>)</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; len(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line">6</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>要坚持使用 UTF-8 格式的编码， 文件需要添加下面的开头</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/usr/bin/env python3</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p><strong>格式化问题</strong></p>
<p>格式化方法和C语言一致，用 <code>%</code> 实现。 <code>%s</code> 代表用字符串替换，<code>%d</code>代表用整数替换，<code>%f</code>代表用浮点数替换，<code>%x</code>代表用十六进制替换。</p>
<blockquote>
<p>‘Hi, %s, you have $%d.’ % (‘Michael’, 1000000)</p>
</blockquote>
<p>格式化整数和浮点数还可以指定是否补0和整数与小数的位数</p>
<p>format()</p>
<p>也可以使用字符串的<code>format()</code> 方法来实现，传入的参数依次替换字符串内的占位符。</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p><strong>if</strong></p>
<p>注意和 java中条件判断写法的区别。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if &lt;条件判断1&gt;:</span><br><span class="line">    &lt;执行1&gt;</span><br><span class="line">elif &lt;条件判断2&gt;:</span><br><span class="line">    &lt;执行2&gt;</span><br><span class="line">elif &lt;条件判断3&gt;:</span><br><span class="line">    &lt;执行3&gt;</span><br><span class="line">else:</span><br><span class="line">    &lt;执行4&gt;</span><br></pre></td></tr></table></figure>

<p><strong>模式匹配</strong></p>
<p>match case</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">age = 15</span><br><span class="line"></span><br><span class="line">match age:</span><br><span class="line">    case x if x &lt; 10:</span><br><span class="line">        print(f&#x27;&lt; 10 years old: &#123;x&#125;&#x27;)</span><br><span class="line">    case 10:</span><br><span class="line">        print(&#x27;10 years old.&#x27;)</span><br><span class="line">    case 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18:</span><br><span class="line">        print(&#x27;11~18 years old.&#x27;)</span><br><span class="line">    case 19:</span><br><span class="line">        print(&#x27;19 years old.&#x27;)</span><br><span class="line">    case _:</span><br><span class="line">        print(&#x27;not sure.&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>python的循环有2种，一种是 for…in 循环，亿次把集合中的元素迭代出来。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">L = [&#x27;Bart&#x27;, &#x27;Lisa&#x27;, &#x27;Adam&#x27;]</span><br><span class="line">for n in L:</span><br><span class="line">    print(&#x27;Hello, %s!&#x27; % n)</span><br></pre></td></tr></table></figure>
<p><strong>while</strong></p>
<p>只要条件满足，就不断循环，条件不满足时，退出循环。</p>
<p>循环控制， <code>break</code> 提前结束循环， <code>continue</code> 跳过当次循环，执行下一次循环。</p>
<h2 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h2><p><strong>list</strong></p>
<p>list是python内置的数据类型，列表，是有序集合。</p>
<p>相关操作有</p>
<ol>
<li>使用 len(list) 获取元素个数</li>
<li>使用索引访问元素，正序从 <code>0</code> 开始，倒序从 <code>-1</code> 开始</li>
<li>list是一个可变的有序表，使用 <code>.append(element)</code>往list中添加元素</li>
<li>也可以使用insert(index, 元素) 方法，将元素插入指定位置。</li>
<li>使用 pop()方法删除末尾元素，pop(i) 方法删除指定位置的元素。</li>
<li>使用 list[i] &#x3D; xxx， 直接替换对应位置的元素。</li>
<li>list中元素的数据类型可以不同。</li>
<li>list中的元素也可以是另一个list的引用。</li>
<li>空list [] ， 长度为0</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names[1]</span></span><br><span class="line">&#x27;b&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; len(names)</span></span><br><span class="line">3</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names[-1]</span></span><br><span class="line">&#x27;c&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names.append(<span class="string">&#x27;d&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names.insert(2, <span class="string">&#x27;f&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;f&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names.pop()</span></span><br><span class="line">&#x27;d&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;f&#x27;, &#x27;c&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names.pop(1)</span></span><br><span class="line">&#x27;b&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;f&#x27;, &#x27;c&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names[1]= <span class="string">&#x27;张三&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; names</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;张三&#x27;, &#x27;c&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>tuple</strong></p>
<p>另一种有序列表叫元组，<code>tuple</code> ，tuple和list非常相似，但是tuple一旦被初始化，就不能修改。</p>
<ol>
<li>tuple 使用小括号进行初始化 <code>()</code></li>
<li>只有一个元素的tuple需要加个逗号<code>,</code>，避免和数据公式中的小括号造成歧义。 (1,)</li>
<li>tuple不可变 意思是元素的指向不可变。</li>
</ol>
<h2 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h2><p><strong>dict</strong></p>
<p>dict全称dictionary，在其他语言中也称为map，是键值对的数据类型。</p>
<blockquote>
<p> d&#x3D;{‘k1’:1, ‘k2’:2, ‘k3’:3}</p>
</blockquote>
<p>相关操作</p>
<ol>
<li>dict中的key必须是 <strong>不可变对象</strong></li>
<li>d[key]&#x3D;xxx 进行赋值。</li>
<li>d[key]来获取对应的value，key不存在时会报错。</li>
<li>用 <code>in</code> 判断key是否存在。</li>
<li>可以使用 <code>get(key)</code>方法获取元素，key不存在会返回 <code>None</code></li>
<li>可以使用 <code>get(key, -1)</code>方法获取元素，key不存在会返回指定的默认值。</li>
<li>使用 <code>pop(key)</code> 来删除key。</li>
<li>元素存放位置，使用hash算法。</li>
</ol>
<p><strong>set</strong></p>
<p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>
<p>要创建一个set，需要提供一个list作为输入集合：</p>
<p><code>s=set([1,2,3,4,5])</code> 或者 <code>s=&#123;1,2,3,4,5&#125;</code></p>
<p>注意要加上 set， 否则就变成了 list了。</p>
<p>set的特点</p>
<ol>
<li>元素无序，不可重复。</li>
<li><code>add(key)</code> 添加元素。</li>
<li><code>remove(key)</code> 移除元素。</li>
<li>set 可以进行交集 <code>&amp;</code> 和 并集 <code>|</code> 的操作。</li>
<li>set和dict的唯一区别仅在于没有存储对应的value。</li>
</ol>
<p>list, tuple, dict, set 的区别</p>
<p>list [] , tuple (), dict {k:v} , set {k1,k2}</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用内建模块1</title>
    <url>/python/python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%971/</url>
    <content><![CDATA[<p>Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。</p>
<p>主要介绍了datetime和collections模块</p>
<span id="more"></span>

<h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><p>datetime是Python处理日期和时间的标准库。</p>
<p><strong>获取当前日期和时间</strong></p>
<p><code>datetime.now()</code>返回的是当前日期和时间。</p>
<p><strong>获取指定日期和时间</strong></p>
<p>要指定某个日期和时间，我们直接用参数构造一个<code>datetime</code></p>
<p><strong>datetime转换为timestamp</strong></p>
<p>timestamp时间戳，timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，注意时区的问题</p>
<p>把一个<code>datetime</code>类型转换为<code>timestamp</code>只需要简单调用<code>timestamp()</code>方法：</p>
<p>Python的timestamp是一个浮点数，整数位表示秒。</p>
<p><strong>timestamp转换为datetime</strong></p>
<p>要把<code>timestamp</code>转换为<code>datetime</code>，使用<code>datetime</code>提供的<code>fromtimestamp()</code>方法：</p>
<p><code>timestamp</code>是一个浮点数，它没有时区的概念，而<code>datetime</code>是有时区的。上述转换是在timestamp和本地时间做转换。本地时间是指当前操作系统设定的时区</p>
<p>timestamp也可以直接被转换到UTC标准时区的时间，使用<code>utcfromtimestamp()</code>方法，后续该方法可能会被移除。</p>
<p><strong>str转换为datetime</strong></p>
<p>把日期和时间的字符串转换为<code>datetime</code>，通过<code>datetime.strptime()</code>实现，需要一个日期和时间的格式化字符串：</p>
<p>格式化字符串参考文档 <a href="https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior">strftime-strptime-behavior</a></p>
<p><strong>datetime转换为str</strong></p>
<p>使用<code>strftime()</code>函数实现，参数需要一个格式化的字符串，和转datetime的一样。</p>
<p><code>now.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取当前日期和时间</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from datetime import datetime</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; now = datetime.now()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(now)</span></span><br><span class="line">2023-12-26 11:36:58.026154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(now))</span></span><br><span class="line">&lt;class &#x27;datetime.datetime&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取指定日期和时间</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; dt = datetime(2023,12,26,11,22,44)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(dt)</span></span><br><span class="line">2023-12-26 11:22:44</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">timestamp</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(dt.timestamp())</span></span><br><span class="line">1703560964.0</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(now.timestamp())</span></span><br><span class="line">1703561818.026154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">转datetime</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; t = 1601234654.1243</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(datetime.fromtimestamp(t))</span></span><br><span class="line">2020-09-28 03:24:14.124300</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(datetime.utcfromtimestamp(t))</span></span><br><span class="line">2020-09-27 19:24:14.124300</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串转datetime</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; day  = datetime.strptime(<span class="string">&#x27;2023-12-01 12:11:01&#x27;</span>, <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day)</span></span><br><span class="line">2023-12-01 12:11:01</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(day))</span></span><br><span class="line">&lt;class &#x27;datetime.datetime&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">datetime转字符串</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(now.strftime( <span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>))</span></span><br><span class="line">2023-12-26 11:36:58</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">datetime 加减计算</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(now)</span></span><br><span class="line">2023-12-26 11:36:58.026154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; nd = now + timedelta(days = 2)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(nd)</span></span><br><span class="line">2023-12-28 11:36:58.026154</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>datetime加减</strong></p>
<p>加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类</p>
<p><strong>本地时间转换为UTC时间</strong></p>
<p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，可以给<code>datetime</code>设置一个时区。</p>
<blockquote>
<p>tz_utc_8 &#x3D; timezone(timedelta(hours&#x3D;8)) # 创建时区UTC+8:00</p>
</blockquote>
<p><strong>时区转换</strong><br>可以先通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间</p>
<p>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from datetime import datetime, timedelta, timezone</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(utc_dt)</span></span><br><span class="line">2023-12-26 06:17:28.304592+00:00</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(bj_dt)</span></span><br><span class="line">2023-12-26 14:17:28.304592+08:00</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; tokyo_dt=bj_dt.astimezone(timezone(timedelta(hours=9)))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(tokyo_dt)</span></span><br><span class="line">2023-12-26 15:17:28.304592+09:00</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="collections集合模块"><a href="#collections集合模块" class="headerlink" title="collections集合模块"></a>collections集合模块</h1><p><strong>namedtuple</strong></p>
<p><code>tuple</code>可以表示不变集合，一个点的二维坐标就可以表示成 <code>p = (1, 2)</code>，但是看到 <code>(1, 2)</code> 很难看出是表示一个坐标的。定义一个calss又小题大做了，这时可以用<code>namedtuple</code></p>
<p><code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>
<p>我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>
<p>可以验证创建的<code>Point</code>对象是<code>tuple</code>的一种子类</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections import namedtuple</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Point = namedtuple(<span class="string">&#x27;Point&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; p = Point(1,2)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; p.x</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(p)</span></span><br><span class="line">&lt;class &#x27;__main__.Point&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance(p, tuple)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>deque</strong></p>
<p>使用<code>list</code>存储数据时，按照索引访问快，但是插入和删除慢，数据量大的时候，效率很低。</p>
<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections import deque</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q = deque([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>])</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.append(<span class="string">&#x27;4&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.appendleft(<span class="string">&#x27;5&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q</span></span><br><span class="line">deque([&#x27;5&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;])</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.pop()</span></span><br><span class="line">&#x27;4&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q.popleft()</span></span><br><span class="line">&#x27;5&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; q</span></span><br><span class="line">deque([&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;])</span><br></pre></td></tr></table></figure>
<p><code>deque</code>除了实现<code>list</code>的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>
<p><strong>defaultdict</strong></p>
<p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望key不存在时，返回一个默认值，就可以用<code>defaultdict</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections import defaultdict</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d = defaultdict(lambda: <span class="string">&#x27;N/A&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d[<span class="string">&#x27;key1&#x27;</span>] = <span class="string">&#x27;1&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d[<span class="string">&#x27;key1&#x27;</span>]</span></span><br><span class="line">&#x27;1&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d[<span class="string">&#x27;key2&#x27;</span>]</span></span><br><span class="line">&#x27;N/A&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p>
<p><strong>OrderedDict</strong></p>
<p><code>dict</code>的key是无序的，如果需要保持key的顺序，使用<code>OrderedDict</code></p>
<p><code>OrderedDict</code>是按照key插入的顺序排序，而不是key本身的顺序。</p>
<p><code>OrderedDict</code>可以实现一个FIFO（先进先出）的<code>dict</code>，当容量超出限制时，先删除最早添加的Key</p>
<p><code>OrderedDict</code>在Python 3.7及以后的版本中，已经不再是必要的，因为从Python 3.7开始，普通的<code>dict</code>对象也会保持元素的插入顺序。</p>
<p>如果想要按照字母顺序排序，可以先对dict排序，然后存入<code>OrderedDict</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="comment"># 创建一个普通的字典</span></span><br><span class="line">unsorted_dict = &#123;<span class="string">&#x27;apple&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;banana&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;orange&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;pear&#x27;</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment"># 按照键的字母顺序对字典进行排序</span></span><br><span class="line">sorted_dict = OrderedDict(<span class="built_in">sorted</span>(unsorted_dict.items()))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>ChainMap</strong></p>
<p><code>ChainMap</code>可以把一组<code>dict</code>串起来并组成一个逻辑上的<code>dict</code>。<code>ChainMap</code>本身也是一个<code>dict</code>，但是查找的时候，会按照顺序在内部的<code>dict</code>依次查找。</p>
<p>什么时候使用ChainMap最合适？举个例子：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用ChainMap实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。</p>
<p><strong>Counter</strong></p>
<p><code>Counter</code>是一个简单的计数器，<code>Counter</code>实际上也是<code>dict</code>的一个子类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.update(<span class="string">&#x27;hahahshashsahashqh2qhewhfwh&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">&#x27;h&#x27;</span>: <span class="number">11</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;s&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;q&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;w&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;f&#x27;</span>: <span class="number">1</span>&#125;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用内建模块3</title>
    <url>/python/python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%973/</url>
    <content><![CDATA[<p>本章主要介绍itertools， contextlib， urllib，XML，HTMLParser的使用。</p>
<span id="more"></span>

<h1 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h1><p><code>itertools</code>提供了非常有用的用于操作迭代对象的函数</p>
<p><code>itertools.count()</code> 自然数无限迭代。</p>
<p><code>itertools.cycle(&#39;abc&#39;)</code>， 将传入的序列无限重复下去</p>
<p><code>repeat()</code> 把一个元素重复下去，可以指定次数。<code>itertools.repeat(&#39;a&#39;, 5)</code></p>
<p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取出一个有限的序列</p>
<p><code>chain()</code>， 可以把一组迭代对象串联起来，组成一个更大的迭代器。<code>itertools.chain(&#39;ABC&#39;, &#39;XYZ&#39;)</code></p>
<p><code>groupby()</code> 把迭代器中相邻的重复元素挑出来放在一起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import itertools</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">for</span> key, group <span class="keyword">in</span> itertools.groupby(<span class="string">&#x27;aabbccaaeeabc&#x27;</span>):</span></span><br><span class="line">...    print(key, list(group))</span><br><span class="line">...</span><br><span class="line">a [&#x27;a&#x27;, &#x27;a&#x27;]</span><br><span class="line">b [&#x27;b&#x27;, &#x27;b&#x27;]</span><br><span class="line">c [&#x27;c&#x27;, &#x27;c&#x27;]</span><br><span class="line">a [&#x27;a&#x27;, &#x27;a&#x27;]</span><br><span class="line">e [&#x27;e&#x27;, &#x27;e&#x27;]</span><br><span class="line">a [&#x27;a&#x27;]</span><br><span class="line">b [&#x27;b&#x27;]</span><br><span class="line">c [&#x27;c&#x27;]</span><br></pre></td></tr></table></figure>

<h1 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h1><p>在Python中，读写文件这样的资源要特别注意，必须在使用完毕后正确关闭它们。正确关闭文件资源的一个方法是使用<code>try...finally</code>，也可以使用<code>with</code>语句进行简化。</p>
<p>并不是只有<code>open()</code>函数返回的fp对象才能使用<code>with</code>语句。实际上，任何对象，只要正确实现了上下文管理，就可以用于<code>with</code>语句。</p>
<p>实现上下文管理是通过<code>__enter__</code>和<code>__exit__</code>这两个方法实现的。</p>
<p>编写<code>__enter__</code>和<code>__exit__</code>仍然很繁琐，因此Python的标准库<code>contextlib</code>提供了更简单的写法。<code>@contextmanager</code>这个decorator接受一个generator，用<code>yield</code>语句把<code>with ... as var</code>把变量输出出去，然后，<code>with</code>语句就可以正常地工作了</p>
<p>很多时候，我们希望在某段代码执行前后自动执行特定代码，也可以用<code>@contextmanager</code>实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tag</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;%s&gt;&quot;</span> % name)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&lt;/%s&gt;&quot;</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tag(<span class="string">&quot;h1&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;world&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>执行顺序</p>
<ol>
<li>with语句首先执行yield之前的语句，</li>
<li>yield调用会执行with语句内部的所有语句，因此打印出hello和world；</li>
<li>最后执行yield之后的语句。</li>
</ol>
<p><strong>@closing</strong></p>
<p>如果一个对象没有实现上下文，我们就不能把它用于<code>with</code>语句。这个时候，可以用<code>closing()</code>来把该对象变为上下文对象。例如，用<code>with</code>语句使用<code>urlopen()</code></p>
<p><code>closing</code>也是一个经过<code>@contextmanager</code>装饰的generator，这个generator编写起来其实非常简单</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">closing</span>(<span class="params">thing</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> thing</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        thing.close()</span><br></pre></td></tr></table></figure>

<h1 id="urllib"><a href="#urllib" class="headerlink" title="urllib"></a>urllib</h1><p>urllib提供了一系列用于操作URL的功能。</p>
<h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>urllib的<code>request</code>模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> request.urlopen(<span class="string">&#x27;https://api.map.baidu.com/location/ip&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">    <span class="built_in">print</span>(f.status)</span><br><span class="line">    <span class="built_in">print</span>(f.reason)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (k, v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Data:&#x27;</span>, data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h2><p>如果要以POST发送一个请求，只需要把参数<code>data</code>以bytes形式传入。 例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reqData = login_data = parse.urlencode([</span><br><span class="line">    (<span class="string">&#x27;ak&#x27;</span>, <span class="string">&#x27;xxxxx&#x27;</span>),</span><br><span class="line">    (<span class="string">&#x27;ip&#x27;</span>, <span class="string">&#x27;117.131.61.81&#x27;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">req = request.Request(<span class="string">&#x27;https://api.map.baidu.com/location/ip&#x27;</span>)</span><br><span class="line">req.add_header(<span class="string">&#x27;user-agent&#x27;</span>, <span class="string">&#x27;chrome&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> request.urlopen(req, data=reqData.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="keyword">as</span> f :</span><br><span class="line">    data = f.read()</span><br><span class="line">    <span class="built_in">print</span>(f.status, f.reason)</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> f.getheaders():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (k, v))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Data:&#x27;</span>, data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用<code>ProxyHandler</code>来处理，示例代码如下：</p>
<h1 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h1><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p>
<p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p>
<h1 id="HTMLParser"><a href="#HTMLParser" class="headerlink" title="HTMLParser"></a>HTMLParser</h1><p>Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用内建模块2</title>
    <url>/python/python%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E6%A8%A1%E5%9D%972/</url>
    <content><![CDATA[<p>本章主要介绍 argparse， bass64， struct，hashlib， hmac的使用。</p>
<span id="more"></span>

<h1 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h1><p>内置的<code>sys.argv</code>保留了完整的参数列表，我们可以从中解析出需要的参数，但是如果参数复杂点，解析起来就很麻烦了，可以使用<code>argparse</code></p>
<p>假设需要编写一个mysql命令行登录程序，需要的参数如下</p>
<blockquote>
<p>mysql -h localhost –port 3306 -u root -p password</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse,sys</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    prog=<span class="string">&#x27;命令行登录&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;命令行登录mysql数据库&#x27;</span>,</span><br><span class="line">    epilog=<span class="string">&#x27;Copyright,2023&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义关键字参数: ，此处不能用 -h简写，和 argparse的-h帮助参数冲突了。</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--host&#x27;</span>, default=<span class="string">&#x27;localhost&#x27;</span>)</span><br><span class="line"><span class="comment"># 此参数必须为int类型:</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--port&#x27;</span>, default=<span class="string">&#x27;3306&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line"><span class="comment"># 允许用户输入简写的-u:</span></span><br><span class="line">parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--user&#x27;</span>, required=<span class="literal">True</span>)</span><br><span class="line">parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;--password&#x27;</span>, required=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析参数:</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.argv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印参数:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;parsed args:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;host = <span class="subst">&#123;args.host&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;port = <span class="subst">&#123;args.port&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;user = <span class="subst">&#123;args.user&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password = <span class="subst">&#123;args.password&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输入有效的参数，能解析出所需要的全部参数。参数不对或者缺失的话，也会有详细的提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python argparse-test.py --host localhost --port 3306 -u root</span><br><span class="line">usage: 命令行登录 [-h] [--host HOST] [--port PORT] -u USER -p PASSWORD</span><br><span class="line">命令行登录: error: the following arguments are required: -p/--password</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输入参数 <code>-h</code> 会有对应的提示信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\workspace\python&gt;python argparse-test.py -h</span><br><span class="line">usage: 命令行登录 [-h] [--host HOST] [--port PORT] -u USER -p PASSWORD</span><br><span class="line"></span><br><span class="line">命令行登录mysql数据库</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  --host HOST</span><br><span class="line">  --port PORT</span><br><span class="line">  -u USER, --user USER</span><br><span class="line">  -p PASSWORD, --password PASSWORD</span><br><span class="line"></span><br><span class="line">Copyright,2023</span><br></pre></td></tr></table></figure>

<p>只有当参数全部有效时，才会返回一个 <a href="https://docs.python.org/3/library/argparse.html#argparse.Namespace">NameSpace</a> 对象，获取对应的参数就把参数名当作属性获取，非常方便</p>
<h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><p>Base64是一种用64个字符来表示任意二进制数据的方法。A-Z、a-z、0-9、”+”和”&#x2F;“两个特殊字符，共计64个字符。因此，在URL安全的Base64编码中，常常将”+”替换为”-“，将”&#x2F;“替换为”_”，以避免引起冲突。</p>
<p>Base64编码将每3个字节的数据转换为4个字符，因此每个字符提供了6个比特位的信息</p>
<p>Base64对二进制数据进行处理，每3个字节一组，一共是<code>3x8=24bit</code>，划为4组，每组正好6个bit：</p>
<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>
<p>示例参考 <a href="https://www.base64decode.org/">example</a>  页面的example部分。<code>Man</code>转换为base64结果为<code>TWFu</code></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-3b7c9b9441623c1c6b5b6099bb897cbc_720w.png" alt="示例图"> </p>
<p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示</p>
<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用<code>\x00</code>字节在末尾补足后，再在编码的末尾加上1个或2个<code>=</code>号，表示补了多少字节，解码的时候，会自动去掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; e64 = base64.b64encode(<span class="string">&#x27;hahaha\x00&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(e64)</span></span><br><span class="line">b&#x27;aGFoYWhhAA==&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d64 = base64.b64decode(b64)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(d64)</span></span><br><span class="line">b&#x27;hahaha&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(d64.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line">hahaha</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>url safe</code>url安全的base64编码。把字符<code>+</code>和<code>/</code>分别变成<code>-</code>和<code>_</code>。使用<code>base64.urlsafe_b64encode()</code>和<code>base64.urlsafe_b64decode()</code></p>
<p>由于<code>=</code>字符也可能出现在Base64编码中，但&#x3D;用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把<code>=</code>去掉</p>
<p>去掉<code>=</code>后怎么解码呢？因为Base64是把<code>3</code>个字节变为<code>4</code>个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上&#x3D;把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>
<h1 id="struct字节和二进制的转换"><a href="#struct字节和二进制的转换" class="headerlink" title="struct字节和二进制的转换"></a>struct字节和二进制的转换</h1><p>准确地讲，Python没有专门处理字节的数据类型。但由于b’str’可以表示字节，所以，字节数组＝二进制str。Python提供了一个<code>struct</code>模块来解决<code>bytes</code>和其他二进制数据类型的转换</p>
<p><code>struct</code>的<code>pack</code>函数把任意数据类型变成<code>bytes</code></p>
<p>pack的第一个参数是处理指令，<code>&#39;&gt;I&#39;</code>的意思是：</p>
<p><code>&gt;</code> 表示字节顺序是big-endian，也就是网络序，<code>I</code>表示4字节无符号整数。</p>
<p>后面的参数个数要和处理指令一致。</p>
<p><code>unpack</code>把<code>bytes</code>变成相应的数据类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import struct</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; struct.pack(<span class="string">&#x27;&gt;I&#x27;</span>, 2234324)</span></span><br><span class="line">b&#x27;\x00&quot;\x17\xd4&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, b<span class="string">&#x27;\x00&quot;\x17\xd4&#x27;</span>)</span></span><br><span class="line">(2234324,)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; struct.unpack(<span class="string">&#x27;&gt;IH&#x27;</span>, b<span class="string">&#x27;\xf0\xf0\xf0\xf0\x80\x80&#x27;</span>)</span></span><br><span class="line">(4042322160, 32896)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>根据<code>&gt;IH</code>的说明，后面的<code>bytes</code>依次变为<code>I</code>：4字节无符号整数和<code>H</code>：2字节无符号整数。</p>
<p>所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。</p>
<p>struct支持的数据类型参考<a href="https://docs.python.org/3/library/struct.html#format-characters">format-characters</a> , </p>
<h1 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h1><p><strong>摘要算法简介</strong></p>
<p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p>
<p>摘要算法，通过摘要函数，计算出固定长度的摘要，用于验证数据，防篡改。</p>
<p>md5 和 sha1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import hashlib</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; md5=hashlib.md5()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; md5.update(<span class="string">&#x27;test&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; md5</span></span><br><span class="line">&lt;md5 _hashlib.HASH object @ 0x0000020B0560E8F0&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(md5.hexdigest())</span></span><br><span class="line">098f6bcd4621d373cade4e832627b4f6</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sha1 = hashlib.sha1()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sha1.update(<span class="string">&#x27;test&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(sha1.hexdigest())</span></span><br><span class="line">a94a8fe5ccb19ba61c4c0873d391e987982fbbd3</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>摘要可能出现hash碰撞的情况，不同的内容计算出来的hash值相同。</p>
<p><strong>摘要算法应用</strong></p>
<p>明文密码加盐，然后计算hash值，进行比对，判断用户输入的密码是否正确</p>
<h1 id="hmac"><a href="#hmac" class="headerlink" title="hmac"></a>hmac</h1><p>如果<code>salt</code>是我们自己随机生成的，通常我们计算MD5时采用<code>md5(message + salt)</code>。</p>
<p>这实际上就是Hmac算法：Keyed-Hashing for Message Authentication。它通过一个标准算法，在计算哈希的过程中，把key混入计算过程中。</p>
<p>Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import hmac</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; message = b<span class="string">&#x27;test&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; key = b<span class="string">&#x27;hahah&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; h = hmac.new(key, message, digestmod=<span class="string">&#x27;SHA1&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(h.hexdigest())</span></span><br><span class="line">5ab4f2d179d1243d6ff9084a0ca659a99bbfcf3f</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用第三方模块</title>
    <url>/python/python%E5%B8%B8%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>可以在<a href="https://pypi.org/">PyPI - the Python Package Index</a> 上查找第三方模块，使用pip安装。主要介绍Pillow，requests，chardet，psutil等</p>
<span id="more"></span>

<h1 id="Pillow"><a href="#Pillow" class="headerlink" title="Pillow"></a>Pillow</h1><p>PIL：Python Imaging Library，是图像处理库，但是仅支持到2.7，兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性。</p>
<p>比如图片压缩和模糊</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;D:/oldimg.jpg&#x27;</span>)</span><br><span class="line">w = img.width</span><br><span class="line">h = img.height</span><br><span class="line"><span class="built_in">print</span>(w, h)</span><br><span class="line">img.thumbnail((w//<span class="number">2</span>, h//<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 模糊滤镜</span></span><br><span class="line">img.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br><span class="line">img.save(<span class="string">&#x27;D:/newimg.jpg&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h1><p>requests 是一个第三方库，处理资源特别方便。</p>
<p><strong>使用requests</strong></p>
<p>requests自动检测编码，可以使用<code>encoding</code>属性查看</p>
<p>无论响应是文本还是二进制内容，我们都可以用<code>content</code>属性获得<code>bytes</code>对象</p>
<p>对于特定类型的响应，例如JSON，可以直接获取 ‘r.json()’</p>
<p>需要传入HTTP Header时，我们传入一个dict作为<code>headers</code>参数</p>
<p>requests默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON数据，可以直接传入json参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = &#123;<span class="string">&#x27;key&#x27;</span>: <span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">r = requests.post(url, json=params) <span class="comment"># 内部自动序列化为JSON</span></span><br></pre></td></tr></table></figure>
<p>上传文件需要更复杂的编码格式，但是<code>requests</code>把它简化成<code>files</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; upload_files = &#123;<span class="string">&#x27;file&#x27;</span>: open(<span class="string">&#x27;report.xls&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; r = requests.post(url, files=upload_files)</span></span><br></pre></td></tr></table></figure>
<p>在读取文件时，注意务必使用<code>&#39;rb&#39;</code>即二进制模式读取，这样获取的<code>bytes</code>长度才是文件的长度。</p>
<p>requests对Cookie做了特殊处理，使得我们不必解析Cookie就可以轻松获取指定的Cookie：</p>
<p>要指定超时，传入以秒为单位的<code>timeout</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">r = requests.get(url, timeout=2.5) # 2.5秒后超时</span><br></pre></td></tr></table></figure>
<p>示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">reqHeader = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;chrome&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r.status_code)</span><br><span class="line">headers = r.headers</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> headers.items():</span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&#x27;=&#x27;</span>, v)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.headers[<span class="string">&#x27;Date&#x27;</span>])</span><br><span class="line"><span class="comment"># cookie</span></span><br><span class="line"><span class="comment"># 打印所有的Cookie值</span></span><br><span class="line">cookies = r.cookies</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;输出cookie信息&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">    <span class="built_in">print</span>(cookie.name, <span class="string">&#x27;:&#x27;</span>, cookie.value)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(r.encoding)</span><br><span class="line"><span class="comment"># print(r.json())</span></span><br></pre></td></tr></table></figure>

<h1 id="chardet"><a href="#chardet" class="headerlink" title="chardet"></a>chardet</h1><p>虽然Python提供了Unicode表示的<code>str</code>和<code>bytes</code>两种数据类型，并且可以通过<code>encode()</code>和<code>decode()</code>方法转换，但是，在不知道编码的情况下，对<code>bytes</code>做<code>decode()</code>不好做。</p>
<p>对于未知编码的<code>bytes</code>，要把它转换成<code>str</code>，需要先“猜测”编码。猜测的方式是先收集各种编码的特征字符，根据特征字符判断，就能有很大概率“猜对”。</p>
<p>chardet 用来检测编码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import chardet</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(b<span class="string">&#x27;12ass&#x27;</span>)</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;ascii&#x27;, &#x27;confidence&#x27;: 1.0, &#x27;language&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;中国&#x27;</span>.encode())</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;utf-8&#x27;, &#x27;confidence&#x27;: 0.7525, &#x27;language&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;中国&#x27;</span>.encode(<span class="string">&#x27;GB2312&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;IBM855&#x27;, &#x27;confidence&#x27;: 0.7679697235616183, &#x27;language&#x27;: &#x27;Russian&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;中国&#x27;</span>.encode(<span class="string">&#x27;GBK&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;IBM855&#x27;, &#x27;confidence&#x27;: 0.7679697235616183, &#x27;language&#x27;: &#x27;Russian&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;中国&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;utf-8&#x27;, &#x27;confidence&#x27;: 0.7525, &#x27;language&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;こんにちは&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;utf-8&#x27;, &#x27;confidence&#x27;: 0.99, &#x27;language&#x27;: &#x27;&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; chardet.detect(<span class="string">&#x27;こんにちは&#x27;</span>.encode(<span class="string">&#x27;EUC-JP&#x27;</span>))</span></span><br><span class="line">&#123;&#x27;encoding&#x27;: &#x27;EUC-JP&#x27;, &#x27;confidence&#x27;: 0.99, &#x27;language&#x27;: &#x27;Japanese&#x27;&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>confidence</code> 字段， 表示检测的概率， 最高是1.0</p>
<h1 id="psutil"><a href="#psutil" class="headerlink" title="psutil"></a>psutil</h1><p>用Python来编写脚本简化日常的运维工作是Python的一个重要用途。psutil &#x3D; process and system utilities，它不仅可以通过一两行代码实现系统监控，还可以跨平台使用。</p>
<p>获取cpu信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import psutil</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; psutil.cpu_count() <span class="comment"># CPU逻辑数量</span></span></span><br><span class="line">8</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; psutil.cpu_count(logical=False) <span class="comment"># CPU物理核心</span></span></span><br><span class="line">4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&quot;4核8线程&quot;</span>是指一个处理器（CPU）具有4个物理核心和8个线程。</span></span><br></pre></td></tr></table></figure>

<p>其他的方法可以查看文档。 <a href="https://pypi.org/project/psutil/">psutil</a>  </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python异步IO</title>
    <url>/python/python%E5%BC%82%E6%AD%A5IO/</url>
    <content><![CDATA[<p>CPU的处理速度和IO的读写速度远远不匹配，会出现阻塞等待的情况，所以引入了多线程或者多进程来提升并行效率，但是线程数量也不能无限增加，否则将会耗费大量的时间在线程切换上。</p>
<p>除了多线程和多进程之外，另一种解决IO问题的方法是异步IO。</p>
<span id="more"></span>

<p>当代码需要执行一个耗时的IO操作时，它只发出IO指令，并不等待IO结果，然后就去执行其他代码了。一段时间后，当IO返回结果时，再通知CPU进行处理。</p>
<p>同步IO模型的代码是无法实现异步IO模型的。异步IO模型需要一个消息循环，在消息循环中，主线程不断地重复“读取消息-处理消息”这一过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loop = get_event_loop()</span><br><span class="line">while True:</span><br><span class="line">    event = loop.get_event()</span><br><span class="line">    process_event(event)</span><br></pre></td></tr></table></figure>
<p>同步IO下，主线程只能挂起等待，异步IO的情况下，主线程可以去处理其他事情，大大提升了IO密集型程序下系统的多任务处理能力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 真正意义上的 异步IO 是说内核直接将数据拷贝至用户态的内存单元，再通知程序直接去读取数据。</span><br><span class="line"># select / poll / epoll 都是同步IO的多路复用模式</span><br><span class="line"></span><br><span class="line"># 1.同步和异步</span><br><span class="line"># 同步和异步关注的是消息通信机制</span><br><span class="line"># 所谓同步，就是在发出一个*调用*时，没得到结果之前，该*调用*就不返回。但是一旦调用返回就得到返回值了，*调用者*主动等待这个*调用*的结果</span><br><span class="line"># 所谓异步，就是在发出一个*调用*时，这个*调用*就直接返回了，不管返回有没有结果。当一个异步过程调用发出后，*被调用者*通过状态，通知来通知*调用者*，或者通过回调函数处理这个调用</span><br><span class="line"></span><br><span class="line"># 2.阻塞和非阻塞</span><br><span class="line"># 阻塞和非阻塞关注的是程序在等待调用结果时的状态</span><br><span class="line"># 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才返回</span><br><span class="line"># 非阻塞调用是指在不能立即得到结果之前，该调用不会阻塞当前线程</span><br><span class="line"></span><br><span class="line"># 网络上的例子</span><br><span class="line">#老张爱喝茶，废话不说，煮开水。</span><br><span class="line">#出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。</span><br><span class="line">#1 老张把水壶放到火上，立等水开。（同步阻塞）；立等就是阻塞了老张去干别的事，老张得一直主动的看着水开没，这就是同步</span><br><span class="line">#2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞）；老张去看电视了，这就是非阻塞了，但是老张还是得关注着水开没，这也就是同步了</span><br><span class="line">#3 老张把响水壶放到火上，立等水开。（异步阻塞）；立等就是阻塞了老张去干别的事，但是老张不用时刻关注水开没，因为水开了，响水壶会提醒他，这就是异步了</span><br><span class="line">#4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞）；老张去看电视了，这就是非阻塞了，而且，等水开了，响水壶会提醒他，这就是异步了</span><br><span class="line">#所谓同步异步，只是对于水壶而言。普通水壶，同步；响水壶，异步。对应的也就是消息通信机制</span><br><span class="line">#虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</span><br><span class="line">#所谓阻塞非阻塞，仅仅对于老张而言。立等的老张，阻塞；对应的也就是程序等待结果时的状态</span><br><span class="line">#看电视的老张，非阻塞。</span><br><span class="line">#情况1和情况3中老张就是阻塞的，媳妇喊他都不知道。虽然3中响水壶是异步的，可对于立等的老张没有太大的意义。所以一般异步是配合非阻塞使用的，这样才能发挥异步的效用。</span><br></pre></td></tr></table></figure>


<h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程，又称微线程，纤程。英文名Coroutine。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>
<p>子程序调用是通过栈实现的，一个线程就是执行一个子程序。子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>比如例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">A</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">B</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;z&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line">3</span><br><span class="line">z</span><br></pre></td></tr></table></figure>

<p>看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</p>
<p>最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。</p>
<p>第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</p>
<p>因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>
<p>Python对协程的支持是通过generator实现的。</p>
<p>在generator中，我们不但可以通过<code>for</code>循环来迭代，还可以不断调用<code>next()</code>函数获取由<code>yield</code>语句返回的下一个值。</p>
<p>但是Python的<code>yield</code>不但可以返回一个值，它还可以接收调用者发出的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[consumer] 消费消息 %s ...&#x27;</span> % n)</span><br><span class="line">        r = <span class="string">&#x27;200 OK&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">c</span>):</span><br><span class="line">    c.send(<span class="literal">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n+<span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[producer] 生产消息 %s ...&#x27;</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;[producer] 消费者返回的结果为 %s ...&#x27;</span> % r)</span><br><span class="line"></span><br><span class="line">    c.close()</span><br><span class="line"></span><br><span class="line">c  = consumer()</span><br><span class="line">producer(c)</span><br></pre></td></tr></table></figure>
<p><code>consumer</code>函数是一个<code>generator</code>，把一个<code>consumer</code>传入producer后：</p>
<p><code>n = yield r</code> 的理解: </p>
<ul>
<li><code>yield r</code> 是将 <code>r</code> 返回给外部调用程序，交出控制权，暂停</li>
<li><code>n = yield</code> 可以接收外部程序通过<code>send()</code>发送的信息，并赋值给 <code>n</code>。 赋值语句在下一次启动生成器的时候首先被执行</li>
</ul>
<p>上面例子的执行过程</p>
<ol>
<li>首先调用<code>c.send(None)</code>启动生成器。功能类似于<code>next(c)</code></li>
<li>然后，一旦生产了东西，通过c.send(n)切换到consumer执行</li>
<li><code>consumer</code>通过<code>yield</code>拿到消息，处理，又通过<code>yield</code>把结果传回</li>
<li><code>produce</code>拿到<code>consumer</code>处理的结果，继续生产下一条消息</li>
<li><code>produce</code>决定不生产了，通过<code>c.close()</code>关闭<code>consumer</code>，整个过程结束</li>
</ol>
<p>整个流程无锁，由一个线程执行，<code>produce</code>和<code>consumer</code>协作完成任务，所以称为“协程”，而非线程的抢占式多任务。</p>
<p>“子程序就是协程的一种特例。”</p>
<h1 id="asyncio-async-await"><a href="#asyncio-async-await" class="headerlink" title="asyncio async&#x2F;await"></a>asyncio async&#x2F;await</h1><p><code>asyncio</code>的编程模型就是一个消息循环。我们从<code>asyncio</code>模块中直接获取一个<code>EventLoop</code>的引用，然后把需要执行的协程扔到<code>EventLoop</code>中执行，就实现了异步IO。</p>
<p>旧版本的使用方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;World&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取Event loop:</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 执行coroutine</span></span><br><span class="line">loop.run_until_complete(main())</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>在 Python 3.7+ 后，我们常常使用 <code>asyncio.run(coroutine)</code> 来代替以上获取<code> eventloop</code>、运行和关闭的操作，因为 <code>asyncio.run</code> 内部已经进行了封装。上述代码可以简化为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello world! %s &quot;</span> % threading.current_thread().name)</span><br><span class="line">    <span class="comment"># 异步调用asyncio.sleep(1):</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello again!  %s &quot;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">asyncio.run(hello())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以在实际编程中，我们很少直接操作 <code>Eventloop</code>，更多的是使用 <code>asyncio</code> 提供的更高层的 API （如 <code>asyncio.run()</code>, <code>asyncio.create_task()</code>, <code>asyncio.sleep()</code> 等）。Eventloop 更多的是被用在开发更底层的库或者理解 asyncio 原理上。</p>
<p>我们用asyncio的异步网络连接来获取多个网站的首页</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">wget</span>(<span class="params">host</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;wget %s...&#x27;</span> % host)</span><br><span class="line">    connect = asyncio.open_connection(host, <span class="number">80</span>)</span><br><span class="line">    reader, writer = <span class="keyword">await</span> connect</span><br><span class="line">    header = <span class="string">&#x27;GET / HTTP/1.0\r\nHost: %s\r\n\r\n&#x27;</span> % host</span><br><span class="line">    writer.write(header.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">await</span> writer.drain()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = <span class="keyword">await</span> reader.readline()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">b&#x27;\r\n&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s header &gt; %s&#x27;</span> % (host, line.decode(<span class="string">&#x27;utf-8&#x27;</span>).rstrip()))</span><br><span class="line">    <span class="comment"># Ignore the body, close the socket</span></span><br><span class="line">    writer.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">multiTasks</span>():</span><br><span class="line">    tasks = [wget(host) <span class="keyword">for</span> host <span class="keyword">in</span> [<span class="string">&#x27;www.sina.com.cn&#x27;</span>, <span class="string">&#x27;www.sohu.com&#x27;</span>, <span class="string">&#x27;www.163.com&#x27;</span>]]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(multiTasks())</span><br></pre></td></tr></table></figure>

<h1 id="aiohttp"><a href="#aiohttp" class="headerlink" title="aiohttp"></a>aiohttp</h1><p><code>asyncio</code>可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。如果把<code>asyncio</code>用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+协程实现多用户的高并发支持。</p>
<p><code>asyncio</code>实现了TCP、UDP、SSL等协议，<code>aiohttp</code>则是基于<code>asyncio</code>实现的HTTP框架。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python模块</title>
    <url>/python/python%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>为了编写可维护的代码，我们把很多函数分组，放到不同的文件中，这样每个文件包含的代码就相对较少，在python中，一个.py文件就称为一个模块(module)。</p>
<span id="more"></span>

<h1 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h1><p>模块可以提升代码的可维护性，可以复用代码，避免函数名和变量名冲突等。</p>
<p>为了避免模块名冲突，又引入了包（Package），按照目录来组织模块。比如将模块放到同一个包<code>mycompany</code> 下面，这样 <code>abc.py</code> 的模块名就变成了 <code>mycompany.abc</code>。</p>
<p>每一个包目录下面都会有一个<code>__init__.py</code>的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包，<code>__init__.py</code>可以是空文件，也可以有Python代码。</p>
<p>也可以有多级目录，组成多级层次的包结构。</p>
<p><strong>模块名不要和系统模块名冲突，否则会导致系统模块引入失败。</strong></p>
<h1 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h1><p>如示例： <code>hello.py</code> 文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; a test module &#x27;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&quot;张三&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    args = sys.argv</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(args)==<span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;hello %s&#x27;</span> % args[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;参数过多&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第1行和第2行是标准注释，第一行可以让该文件在linux下直接运行，第二行注释说明了使用的编码。</p>
<p>第4行是一个字符串，是模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</p>
<p>第6行使用<code>__author__</code>变量把作者写进去</p>
<p>上面就是python模块的标准文件模板。后面开始就是真正的代码部分。</p>
<p>导入<code>sys</code>模块后，我们就有了变量<code>sys</code>指向该模块，利用<code>sys</code>这个变量，就可以访问<code>sys</code>模块的所有功能。</p>
<p>最后的两行特殊的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if __name__==&#x27;__main__&#x27;:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<p>在命令行运行<code>hello</code>模块文件时，Python解释器把一个特殊变量<code>__name__</code>置为<code>__main__</code>，而如果在其他地方导入该<code>hello</code>模块时，<code>if</code>判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>一个模块中，可能有很多的变量和函数，有些函数和变量希望给别人使用，有的函数和变量希望仅仅在模块内部使用，在python中，是通过前缀<code>_</code> 实现的。</p>
<p>正常的函数和变量名是公开的(public)， 可以被直接引用，如<code>abc</code>，<code>hello</code>等。</p>
<p>类似<code>__xx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊的用途。模块的文档注释也可以用<code>__doc__</code>变量来访问。我们自己的变量一般不要用这样的变量名。</p>
<p>类似<code>_xxx</code>和<code>__xxx</code> 这样的变量或者函数就是非公开的(private)，不应该被直接引用。</p>
<p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>
<blockquote>
<p>外部不需要引用的函数全部定义成private，只有外部需要引用的函数才定义为public。</p>
</blockquote>
<h1 id="安装第三方模块"><a href="#安装第三方模块" class="headerlink" title="安装第三方模块"></a>安装第三方模块</h1><p>可以通过命令来安装第三方模块。</p>
<blockquote>
<p>pip install xxx</p>
</blockquote>
<p><strong>模块搜索路径</strong></p>
<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import sys</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; sys.path</span></span><br><span class="line">[&#x27;&#x27;, &#x27;C:\\Python312\\python312.zip&#x27;, &#x27;C:\\Python312\\DLLs&#x27;, &#x27;C:\\Python312\\Lib&#x27;, &#x27;C:\\Python312&#x27;, &#x27;C:\\Python312\\Lib\\site-packages&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果我们要添加自己的搜索路径，可以设置环境变量 <code>PYTHONPATH</code>， 该环境变量的内容会被自动添加到模块搜索路径中。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python正则表达式</title>
    <url>/python/python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。</p>
<p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>
<span id="more"></span>

<p>正则表达式基础的表示方式，如数字，开头，结尾等，可以参考相关文档。</p>
<p><a href="https://www.runoob.com/regexp/regexp-syntax.html">菜鸟教程-正则表达式</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions">Regular_expressions</a></p>
<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>Python提供<code>re</code>模块，包含所有正则表达式的功能。由于Python的字符串本身也用<code>\</code>转义，所以要特别注意：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s = &#x27;ABC\\-001&#x27; # Python的字符串</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对应的正则表达式字符串变成：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;ABC\-001&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>所以强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">s = r&#x27;ABC\-001&#x27; # Python的字符串</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对应的正则表达式字符串不变：</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">&#x27;ABC\-001&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>使用正则进行匹配</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import re</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.match(r<span class="string">&#x27;\d+&#x27;</span>, <span class="string">&#x27;111&#x27;</span>)</span></span><br><span class="line">&lt;re.Match object; span=(0, 3), match=&#x27;111&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.match(r<span class="string">&#x27;\d+&#x27;</span>, <span class="string">&#x27;aa&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。常见的判断方法就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = <span class="string">&#x27;字符串&#x27;</span></span><br><span class="line"><span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&#x27;正则表达式&#x27;</span>, test):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;failed&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2><p>用正则表达式切分字符串比用固定的字符更灵活</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;a b    c  d     e&#x27;</span>.<span class="built_in">split</span>(<span class="string">&#x27; &#x27;</span>)</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;c&#x27;, &#x27;&#x27;, &#x27;d&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;e&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.split(r<span class="string">&#x27;\s+&#x27;</span> , <span class="string">&#x27;a b    c  d     e&#x27;</span>)</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.split(r<span class="string">&#x27;[\s\,]+&#x27;</span> , <span class="string">&#x27;a b  , ,  c , d     e&#x27;</span>)</span></span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br></pre></td></tr></table></figure>

<p>可以看出来使用正则更加灵活和强大，便于把不规范的输入转换成正确的数组。</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如</p>
<p><code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m = re.match(r<span class="string">&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>, <span class="string">&#x27;010-12345&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m</span></span><br><span class="line">&lt;re.Match object; span=(0, 9), match=&#x27;010-12345&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m.group(0)</span></span><br><span class="line">&#x27;010-12345&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m.group(1)</span></span><br><span class="line">&#x27;010&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m.group(2)</span></span><br><span class="line">&#x27;12345&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果正则表达式中定义了组，就可以在Match对象上用<code>group()</code>方法提取出子串来。</p>
<p><code>group(0)</code>永远是与整个正则表达式相匹配的字符串，<code>group(1)</code>、<code>group(2)</code>……表示第1、2、……个子串。</p>
<h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的<code>0</code>， 加上 <code>?</code> 说明采用非贪婪模式。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.match(r<span class="string">&#x27;(\d+)(0*)$&#x27;</span>, <span class="string">&#x27;102010&#x27;</span>).<span class="built_in">groups</span>()</span></span><br><span class="line">(&#x27;102010&#x27;, &#x27;&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re.match(r<span class="string">&#x27;(\d+?)(0*)$&#x27;</span>, <span class="string">&#x27;10201000&#x27;</span>).<span class="built_in">groups</span>()</span></span><br><span class="line">(&#x27;10201&#x27;, &#x27;000&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>\d+</code> 采用非贪婪模式，后面加上<code>?</code> ，改为 <code>(\d+?)</code></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>
<ol>
<li><p>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</p>
</li>
<li><p>用编译后的正则表达式去匹配字符串。</p>
</li>
</ol>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配(和java一样)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import re</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译:</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re_telephone = re.compile(r<span class="string">&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用：</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; re_telephone.match(<span class="string">&#x27;010-12345&#x27;</span>).<span class="built_in">groups</span>()</span></span><br><span class="line">(&#x27;010&#x27;, &#x27;12345&#x27;)</span><br></pre></td></tr></table></figure>

<p>编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python电子邮件</title>
    <url>/python/python%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<p>使用SMTP发送邮件，使用POP3接收邮件。</p>
<span id="more"></span>

<h1 id="SMTP发送邮件"><a href="#SMTP发送邮件" class="headerlink" title="SMTP发送邮件"></a>SMTP发送邮件</h1><p>SMTP是发送邮件的协议，Python内置对SMTP的支持，可以发送纯文本邮件、HTML邮件以及带附件的邮件。</p>
<p>Python对SMTP支持有<code>smtplib</code>和<code>email</code>两个模块，<code>email</code>负责构造邮件，<code>smtplib</code>负责发送邮件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line">msg = MIMEText(<span class="string">&#x27;测试下邮件发送&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意到构造<code>MIMEText</code>对象时，第一个参数就是邮件正文，第二个参数是MIME的subtype，传入<code>&#39;plain&#39;</code>表示纯文本，最终的MIME就是<code>&#39;text/plain&#39;</code>，最后一定要用<code>utf-8</code>编码保证多语言兼容性。</p>
<p>然后，通过SMTP发出去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.utils <span class="keyword">import</span> formataddr, parseaddr</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_format_addr</span>(<span class="params">s</span>):</span><br><span class="line">    name, addr = parseaddr(s)</span><br><span class="line">    <span class="keyword">return</span> formataddr((Header(name, <span class="string">&#x27;utf-8&#x27;</span>).encode(), addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入Email地址和口令:</span></span><br><span class="line">from_addr = <span class="string">&#x27;xxxxxx&#x27;</span></span><br><span class="line">password = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line"><span class="comment"># 输入收件人地址:</span></span><br><span class="line">to_addr = <span class="string">&#x27;xxx@qq.com&#x27;</span></span><br><span class="line"><span class="comment"># 输入SMTP服务器地址:</span></span><br><span class="line">smtp_server = <span class="string">&#x27;xxx.xxx.com&#x27;</span></span><br><span class="line"></span><br><span class="line">msg = MIMEText(<span class="string">&#x27;哈哈哈哈哈&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = _format_addr(<span class="string">&#x27;测试下邮件发送 &lt;%s&gt;&#x27;</span> % from_addr)</span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = _format_addr(<span class="string">&#x27;管理员 &lt;%s&gt;&#x27;</span> % to_addr)</span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&#x27;来自SMTP的问候……&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">25</span>) <span class="comment"># SMTP协议默认端口是25</span></span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line">server.login(from_addr, password)</span><br><span class="line">server.sendmail(from_addr, [to_addr], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>
<p>我们用<code>set_debuglevel(1)</code>就可以打印出和SMTP服务器交互的所有信息。SMTP协议就是简单的文本命令和响应。<code>login()</code>方法用来登录SMTP服务器，<code>sendmail()</code>方法就是发邮件，由于可以一次发给多个人，所以传入一个<code>list</code>，邮件正文是一个<code>str</code>，<code>as_string()</code>把<code>MIMEText</code>对象变成<code>str</code>。</p>
<p>必须把<code>From</code>、<code>To</code>和<code>Subject</code>添加到<code>MIMEText</code>中，才是一封完整的邮件， 否则无法显示主题，收件人等信息。</p>
<h2 id="发送HTML邮件"><a href="#发送HTML邮件" class="headerlink" title="发送HTML邮件"></a>发送HTML邮件</h2><p>如果我们要发送HTML邮件，方法很简单，在构造<code>MIMEText</code>对象时，把<code>HTML</code>字符串传进去，再把第二个参数由<code>plain</code>变为<code>html</code>就可以了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg = MIMEText(<span class="string">&#x27;&lt;h1&gt;哈哈哈哈哈&lt;/h1&gt;&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="发送附件"><a href="#发送附件" class="headerlink" title="发送附件"></a>发送附件</h2><p>可以构造一个<code>MIMEMultipart</code>对象代表邮件本身，然后往里面加上一个<code>MIMEText</code>作为邮件正文，再继续往里面加上表示附件的<code>MIMEBase</code>对象即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg = MIMEMultipart()</span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = _format_addr(<span class="string">&#x27;Python爱好者 &lt;%s&gt;&#x27;</span> % from_addr)</span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = _format_addr(<span class="string">&#x27;管理员 &lt;%s&gt;&#x27;</span> % to_addr)</span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = Header(<span class="string">&#x27;来自SMTP的问候……&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>).encode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件正文是MIMEText:</span></span><br><span class="line">msg.attach(MIMEText(<span class="string">&#x27;send with file...&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加附件就是加上一个MIMEBase，从本地读取一个图片:</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;D:/oldimg.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 设置附件的MIME和文件名，这里是png类型:</span></span><br><span class="line">    mime = MIMEBase(<span class="string">&#x27;image&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, filename=<span class="string">&#x27;oldimg.jpg&#x27;</span>)</span><br><span class="line">    <span class="comment"># 加上必要的头信息:</span></span><br><span class="line">    mime.add_header(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">&#x27;attachment&#x27;</span>, filename=<span class="string">&#x27;oldimg.jpg&#x27;</span>)</span><br><span class="line">    mime.add_header(<span class="string">&#x27;Content-ID&#x27;</span>, <span class="string">&#x27;&lt;0&gt;&#x27;</span>)</span><br><span class="line">    mime.add_header(<span class="string">&#x27;X-Attachment-Id&#x27;</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="comment"># 把附件的内容读进来:</span></span><br><span class="line">    mime.set_payload(f.read())</span><br><span class="line">    <span class="comment"># 用Base64编码:</span></span><br><span class="line">    encoders.encode_base64(mime)</span><br><span class="line">    <span class="comment"># 添加到MIMEMultipart:</span></span><br><span class="line">    msg.attach(mime)</span><br></pre></td></tr></table></figure>
<p>然后，按正常发送流程把msg（注意类型已变为<code>MIMEMultipart</code>）发送出去，就可以收到如下带附件的邮件</p>
<h2 id="发送图片"><a href="#发送图片" class="headerlink" title="发送图片"></a>发送图片</h2><p>如果要把一个图片嵌入到邮件正文中怎么做？直接在HTML邮件中链接图片地址行不行？答案是，大部分邮件服务商都会自动屏蔽带有外链的图片，因为不知道这些链接是否指向恶意网站。</p>
<p>要把图片嵌入到邮件正文中，我们只需按照发送附件的方式，先把邮件作为附件添加进去，然后，在HTML中通过引用<code>src=&quot;cid:0&quot;</code>就可以把附件作为图片嵌入了。如果有多个图片，给它们依次编号，然后引用不同的<code>cid:x</code>即可。</p>
<p>把上面代码加入<code>MIMEMultipart</code>的<code>MIMEText</code>从<code>plain</code>改为<code>html</code>，然后在适当的位置引用图片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg.attach(MIMEText(<span class="string">&#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;下面是一个图片&lt;/h1&gt;&lt;br/&gt;&lt;img src=&quot;cid:0&quot;&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>


<h2 id="同时支持HTML和Plain格式"><a href="#同时支持HTML和Plain格式" class="headerlink" title="同时支持HTML和Plain格式"></a>同时支持HTML和Plain格式</h2><p>为了兼容旧设备，在发送HTML的同时再附加一个纯文本，如果收件人无法查看HTML格式的邮件，就可以自动降级查看纯文本邮件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">msg = MIMEMultipart(<span class="string">&#x27;alternative&#x27;</span>)</span><br><span class="line">msg[<span class="string">&#x27;From&#x27;</span>] = ...</span><br><span class="line">msg[<span class="string">&#x27;To&#x27;</span>] = ...</span><br><span class="line">msg[<span class="string">&#x27;Subject&#x27;</span>] = ...</span><br><span class="line"></span><br><span class="line">msg.attach(MIMEText(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;plain&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">msg.attach(MIMEText(<span class="string">&#x27;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>, <span class="string">&#x27;html&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="comment"># 正常发送msg对象...</span></span><br></pre></td></tr></table></figure>

<h2 id="加密SMTP"><a href="#加密SMTP" class="headerlink" title="加密SMTP"></a>加密SMTP</h2><p>使用标准的25端口连接SMTP服务器时，使用的是明文传输，发送邮件的整个过程可能会被窃听。要更安全地发送邮件，可以加密SMTP会话，实际上就是先创建SSL安全连接，然后再使用SMTP协议发送邮件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">server = smtplib.SMTP(smtp_server, <span class="number">465</span>) </span><br><span class="line">server.starttls()</span><br></pre></td></tr></table></figure>
<p>只需要在创建SMTP对象后，立刻调用starttls()方法，就创建了安全连接。后面的代码和前面的发送邮件代码完全一样。</p>
<p>构造一个邮件对象就是一个<code>Messag</code>对象，如果构造一个<code>MIMEText</code>对象，就表示一个文本邮件对象，如果构造一个<code>MIMEImage</code>对象，就表示一个作为附件的图片，要把多个对象组合起来，就用<code>MIMEMultipart</code>对象，而<code>MIMEBase</code>可以表示任何对象。它们的继承关系如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Message</span><br><span class="line">+- MIMEBase</span><br><span class="line">   +- MIMEMultipart</span><br><span class="line">   +- MIMENonMultipart</span><br><span class="line">      +- MIMEMessage</span><br><span class="line">      +- MIMEText</span><br><span class="line">      +- MIMEImage</span><br></pre></td></tr></table></figure>
<p>这种嵌套关系就可以构造出任意复杂的邮件。</p>
<h1 id="POP3收取邮件"><a href="#POP3收取邮件" class="headerlink" title="POP3收取邮件"></a>POP3收取邮件</h1><p>Python内置一个<code>poplib</code>模块，实现了POP3协议，可以直接用来收邮件。</p>
<p>注意到POP3协议收取的不是一个已经可以阅读的邮件本身，而是邮件的原始文本，这和SMTP协议很像，SMTP发送的也是经过编码后的一大段文本。</p>
<p>要把POP3收取的文本变成可以阅读的邮件，还需要用email模块提供的各种类来解析原始文本，变成可阅读的邮件对象。</p>
<p>所以，收取邮件分两步：</p>
<p>第一步：用<code>poplib</code>把邮件的原始文本下载到本地；</p>
<p>第二步：用<code>email</code>解析原始文本，还原为邮件对象。</p>
<h2 id="通过POP3下载邮件"><a href="#通过POP3下载邮件" class="headerlink" title="通过POP3下载邮件"></a>通过POP3下载邮件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> poplib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入邮件地址, 口令和POP3服务器地址:</span></span><br><span class="line">email = <span class="built_in">input</span>(<span class="string">&#x27;Email: &#x27;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&#x27;Password: &#x27;</span>)</span><br><span class="line">pop3_server = <span class="built_in">input</span>(<span class="string">&#x27;POP3 server: &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到POP3服务器:</span></span><br><span class="line">server = poplib.POP3(pop3_server)</span><br><span class="line"><span class="comment"># 可以打开或关闭调试信息:</span></span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 可选:打印POP3服务器的欢迎文字:</span></span><br><span class="line"><span class="built_in">print</span>(server.getwelcome().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 身份认证:</span></span><br><span class="line">server.user(email)</span><br><span class="line">server.pass_(password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stat()返回邮件数量和占用空间:</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Messages: %s. Size: %s&#x27;</span> % server.stat())</span><br><span class="line"><span class="comment"># list()返回所有邮件的编号:</span></span><br><span class="line">resp, mails, octets = server.<span class="built_in">list</span>()</span><br><span class="line"><span class="comment"># 可以查看返回的列表类似[b&#x27;1 82923&#x27;, b&#x27;2 2184&#x27;, ...]</span></span><br><span class="line"><span class="built_in">print</span>(mails)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取最新一封邮件, 注意索引号从1开始:</span></span><br><span class="line">index = <span class="built_in">len</span>(mails)</span><br><span class="line">resp, lines, octets = server.retr(index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lines存储了邮件的原始文本的每一行,</span></span><br><span class="line"><span class="comment"># 可以获得整个邮件的原始文本:</span></span><br><span class="line">msg_content = <span class="string">b&#x27;\r\n&#x27;</span>.join(lines).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 稍后解析出邮件:</span></span><br><span class="line">msg = Parser().parsestr(msg_content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以根据邮件索引号直接从服务器删除邮件:</span></span><br><span class="line"><span class="comment"># server.dele(index)</span></span><br><span class="line"><span class="comment"># 关闭连接:</span></span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>

<p>用POP3获取邮件其实很简单，要获取所有邮件，只需要循环使用<code>retr()</code>把每一封邮件内容拿到即可。真正麻烦的是把邮件的原始内容解析为可以阅读的邮件对象。</p>
<h2 id="解析邮件"><a href="#解析邮件" class="headerlink" title="解析邮件"></a>解析邮件</h2><p>解析邮件的过程和上一节构造邮件正好相反，因此，先导入必要的模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">from email.parser import Parser</span><br><span class="line">from email.header import decode_header</span><br><span class="line">from email.utils import parseaddr</span><br><span class="line"></span><br><span class="line">import poplib</span><br></pre></td></tr></table></figure>
<p>只需要一行代码就可以把邮件内容解析为<code>Message</code>对象：</p>
<p>但是这个<code>Message</code>对象本身可能是一个<code>MIMEMultipart</code>对象，即包含嵌套的其他<code>MIMEBase</code>对象，嵌套可能还不止一层。</p>
<p>所以我们要递归地打印出<code>Message</code>对象的层次结构：</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python的IO编程</title>
    <url>/python/python%E7%9A%84IO%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>IO在计算机中指Input&#x2F;Output，也就是输入和输出。如磁盘IO，网络IO等。Stream（流）是一个很重要的概念，输入流和输出流。</p>
<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。可以分为同步和异步处理。</p>
<p>异步IO又包含了回调模模式和轮询模式等，在网络IO编程中比较常用。</p>
<span id="more"></span>

<h1 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h1><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p>
<p>操作系统不允许普通程序直接操作磁盘，读写文件就是请求操作系统打开一个文件对象(通常称为文件描述符)，然后通过操作系统的接口进行读写操作。</p>
<h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><p>读文件，用Python内置的<code>open()</code>函数，传入文件名和标示符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f=open(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f=open(<span class="string">&#x27;D:/imgUrl.txtaa&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:/imgUrl.txtaa&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>标示符<code>&#39;r&#39;</code>表示读，如果文件不存在，<code>open()</code>函数就会抛出一个<code>IOError</code>的错误，并且给出错误码和详细的信息告诉你文件不存在</p>
<p>调用<code>read()</code>方法可以一次把文件内容读取到内存中，用一个<code>str</code>对象表示。</p>
<p>最后一定要调用<code>close()</code>关闭文件，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的。和java一样。</p>
<p>文件读取出错后，后面的close就不会执行了。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>

<p>但是每次都这样写太麻烦， Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure>

<p>这和<code>try ... finally</code>是一样的，但是代码更简洁。</p>
<p>调用<code>read()</code>会一次将文件内容读取到内存中，如果文件过大，内存就爆了，可以使用分治的方法，每次读取一部分内容。反复调用<code>read(size)</code>方法，每次最多读取<code>size</code>个字节的内容</p>
<p>另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>
<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>
<p>可以使用 <code>line.strip()</code> 把末尾的<code>\n</code> 换行符去掉</p>
<p>例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读文件遍历 </span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">open</span>(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 直接迭代文件对象</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment">#print(len(line))</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一次全部读入内存</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">open</span>(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    l = f.readlines()</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">len</span>(l))</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> l:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="comment">#print(s.strip())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行读取</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">open</span>(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        <span class="comment">#print(line.strip())</span></span><br><span class="line">        line = f.readline()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按size读取</span></span><br><span class="line"><span class="keyword">with</span>(<span class="built_in">open</span>(<span class="string">&#x27;D:/imgUrl.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)) <span class="keyword">as</span> f:</span><br><span class="line">    size = <span class="number">50</span></span><br><span class="line">    data = f.read(size)</span><br><span class="line">    <span class="keyword">while</span> data:</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        data = f.read(size)</span><br></pre></td></tr></table></figure>

<h2 id="file-like-Object"><a href="#file-like-Object" class="headerlink" title="file-like Object"></a>file-like Object</h2><p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p>
<p><code>StringIO</code> 就是在内存中创建的file-like Object，常用作临时缓冲。</p>
<h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>上面的默认都是读取的<code>utf-8</code>编码的文本文件，如果是二进制文件，比如图片等，需要用<code>&#39;rb&#39;</code> 模式打开文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f = open(<span class="string">&#x27;D:/123.png&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.readline()</span></span><br><span class="line">b&#x27;\x89PNG\r\n&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f=open(<span class="string">&#x27;D:/gb2312-test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gb2312&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.readline()</span></span><br><span class="line">&#x27;中文编码测试\n&#x27;</span><br></pre></td></tr></table></figure>

<p>如果有一些非法的编码，可能会报错<code>UnicodeDecodeError</code>，可以指定<code>errors</code>参数忽略错误</p>
<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;D:/write-test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;哈哈哈哈\n&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以反复调用<code>write()</code>来写文件，但是一定要调用<code>f.close()</code>方法来关闭文件，否则可能发会导致要写入的数据只写了一部分。只有调用<code>close()</code>方法时，操作系统才保证把没有写入的数据全部写入磁盘。</p>
<p>所以还是使用<code>with</code>最保险</p>
<p>要写入特定编码的文本文件，可以给<code>open()</code>函数传入<code>encoding</code>参数</p>
<p>以 <code>&#39;w&#39;</code>模式写文件时，每次写入会覆盖，可以将<code>&#39;w&#39;</code> 改为 <code>&#39;a&#39;</code> 来使用追加模式写入。</p>
<h1 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h1><h2 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h2><p>很多时候，数据读写不一定是文件，也可以在内存中读写。</p>
<p>StringIO就是在内存中读写str。要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from io import StringIO</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f = StringIO()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.write(<span class="string">&#x27;大&#x27;</span>)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.write(<span class="string">&#x27;\n&#x27;</span>)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.write(<span class="string">&#x27;家好&#x27;</span>)</span></span><br><span class="line">2</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; f.getvalue()</span></span><br><span class="line">&#x27;大\n家好&#x27;</span><br></pre></td></tr></table></figure>

<p><code>getvalue()</code>方法用于获得写入后的str。</p>
<p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = StringIO(<span class="string">&#x27;大\n家\n好&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    s = f.readline()</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(s.strip())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h2><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p>
<p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p>
<p>写入的不是str，而是经过UTF-8编码的bytes</p>
<p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = BytesIO()</span><br><span class="line">f.write(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(f.getvalue())</span><br><span class="line"><span class="built_in">print</span>(f.getvalue().decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用bytes初始化</span></span><br><span class="line">f = BytesIO(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure>

<h1 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h1><p>内置的<code>os</code>模块可以直接调用操作系统提供的接口操作文件和目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import os</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.name</span></span><br><span class="line">&#x27;posix&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.uname()</span></span><br><span class="line">(&#x27;Linux&#x27;, &#x27;dev&#x27;, &#x27;3.10.0-1160.90.1.el7.x86_64&#x27;, &#x27;#1 SMP Thu May 4 15:21:22 UTC 2023&#x27;, &#x27;x86_64&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; os.name</span></span><br><span class="line">&#x27;nt&#x27;</span><br></pre></td></tr></table></figure>

<p>如果是<code>posix</code>，说明系统是<code>Linux</code>、<code>Unix</code>或<code>Mac OS X</code>，如果是<code>nt</code>，就是<code>Windows</code>系统。</p>
<p>要获取详细的系统信息，可以调用<code>uname()</code>函数, windows系统不支持该函数。<code>os</code>模块的某些函数是跟操作系统相关的</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><code>os.environ</code> 可以查看全部的环境变量。要获取某个环境变量的值，可以调用<code>os.environ.get(&#39;key&#39;)</code>：</p>
<h2 id="操作文件和目录-1"><a href="#操作文件和目录-1" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中。</p>
<p>把两个路径合成一个时，不要直接拼字符串，而要通过<code>os.path.join()</code>函数，这样可以正确处理不同操作系统的路径分隔符。</p>
<p>拆分路径的时候，要使用<code>os.path.split()</code>，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。</p>
<p><code>os.path.splitext()</code>可以直接得到文件的扩展名。</p>
<p>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</p>
<p><code>os.rename()</code> 对文件重命名。<code>os.remove</code> 删除文件。</p>
<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><p>程序运行的过程中，所有的变量都是在内存中。在程序运行结束后，变量就会被操作系统回收。</p>
<p>把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思</p>
<p>序列化之后，就可以把序列化的内容写入到磁盘，或者通过网络传输。</p>
<p>把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>
<h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>Python提供了<code>pickle</code>模块来实现序列化。</p>
<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>bytes</code>，然后，就可以把这个<code>bytes</code>写入文件。</p>
<p>或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个file-like Object：</p>
<p>当我们要把对象从磁盘读到内存时，可以先把内容读到一个<code>bytes</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个file-like Object中直接反序列化出对象。</p>
<p>通过这种方式反序列化的变量内容相同，但是实际上不是同一个变量了。</p>
<p>Pickle的序列化只能用于python，可能python的不同版本也不兼容，也不能跨语言。所以不能保存重要的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(pickle.dumps(l))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化到文件中</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;D:/tmpdump.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dump(l, f)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反序列化 先读取成bytes</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;D:/tmpdump.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">b = f.read()</span><br><span class="line">data = pickle.loads(b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(data))</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接从文件反序列化</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;D:/tmpdump.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">d = pickle.load(f)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">b&#x27;\x80\x04\x95\x17\x00\x00\x00\x00\......省略....&#x27;</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON。</p>
<p>JSON和Python内置的数据类型对应如下</p>
<table>
<thead>
<tr>
<th align="left">JSON类型</th>
<th align="left">Python类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">{}</td>
<td align="left">dict</td>
</tr>
<tr>
<td align="left">[]</td>
<td align="left">list</td>
</tr>
<tr>
<td align="left">“string”</td>
<td align="left">str</td>
</tr>
<tr>
<td align="left">12.3</td>
<td align="left">int或float</td>
</tr>
<tr>
<td align="left">true&#x2F;false</td>
<td align="left">True&#x2F;False</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">None</td>
</tr>
</tbody></table>
<p>Python内置的json模块提供了非常完善的Python对象到JSON格式的转换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d = dict(name=<span class="string">&#x27;张三&#x27;</span>, age=20, height=130.5, interest=[<span class="string">&#x27;篮球&#x27;</span>, <span class="string">&#x27;唱歌&#x27;</span>])</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; d</span></span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 20, &#x27;height&#x27;: 130.5, &#x27;interest&#x27;: [&#x27;篮球&#x27;, &#x27;唱歌&#x27;]&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.dumps(d)</span></span><br><span class="line">&#x27;&#123;&quot;name&quot;: &quot;\\u5f20\\u4e09&quot;, &quot;age&quot;: 20, &quot;height&quot;: 130.5, &quot;interest&quot;: [&quot;\\u7bee\\u7403&quot;, &quot;\\u5531\\u6b4c&quot;]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.dumps(d,ensure_ascii=False)</span></span><br><span class="line">&#x27;&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;height&quot;: 130.5, &quot;interest&quot;: [&quot;篮球&quot;, &quot;唱歌&quot;]&#125;&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s=json.dumps(d)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; json.loads(s)</span></span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 20, &#x27;height&#x27;: 130.5, &#x27;interest&#x27;: [&#x27;篮球&#x27;, &#x27;唱歌&#x27;]&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>dumps()</code>方法返回一个<code>str</code>，内容是标准的json，类似的 <code>dump()</code>方法可以直接把json写入到<code>file-like Object</code></p>
<p>使用<code>loads()</code>方法把json字符串反序列化，或者使用<code>load()</code>方法从<code>file-like Object</code>中读取字符串并反序列化。</p>
<h2 id="JSON进阶"><a href="#JSON进阶" class="headerlink" title="JSON进阶"></a>JSON进阶</h2><p><code>dict</code>对象可以直接序列化为JSON的<code>&#123;&#125;</code>，不过，很多时候，我们更喜欢用class表示对象，比如定义Student类，然后序列化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>, <span class="number">20</span>, <span class="number">88</span>)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(s))</span><br></pre></td></tr></table></figure>

<p>运行时，会报<code>TypeError</code>，是因为<code>Student</code>对象不是一个可序列化为JSON的对象。</p>
<p><code>dumps()</code>函数有很多可选参数，可以用来定制json序列化。</p>
<p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">student2dict</span>(<span class="params">std</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&#x27;name&#x27;</span>: std.name,</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span>: std.age,</span><br><span class="line">        <span class="string">&#x27;score&#x27;</span>: std.score</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(json.dumps(s, default=student2dict))</span><br></pre></td></tr></table></figure>

<p>不过，如果遇到其他类的实例，依然无法序列化，可以默认把任意<code>class</code>的实例变为<code>dict</code></p>
<blockquote>
<p>print(json.dumps(s, default&#x3D;lambda obj: obj.<strong>dict</strong>))</p>
</blockquote>
<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个<code>dict</code>，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>
<p>如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个<code>dict</code>对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;height&quot;: 130.5, &quot;interest&quot;: [&quot;篮球&quot;, &quot;唱歌&quot;]&#125;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; stu = json.loads(s, object_hook=dict2student)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(stu)</span></span><br><span class="line">&lt;__main__.Student object at 0x000002615C4962A0&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(json.dumps(stu, default=lambda obj: obj.__dict__, ensure_ascii=False))</span></span><br><span class="line">&#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;score&quot;: 130.5&#125;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ensure_ascii</code>用于指定在对JSON进行编码时是否对非ASCII字符进行转义，确保生成的JSON字符串中只包含ASCII字符。</p>
<p><code>ensure_ascii</code>参数默认值为True，表示会对非ASCII字符进行转义，将其表示为<code>\uXXXX</code>的形式。 如果将<code>ensure_ascii</code>参数设置为<code>False</code>，则表示不对非ASCII字符进行转义。非ASCII字符将以原样包含在生成的JSON字符串中。</p>
<p>通常情况下，需要保持默认值，这样可以确保生成的JSON字符串是有效的ASCII字符串，可以在不同的系统之间进行传输和解析。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python网络编程</title>
    <url>/python/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>网络通信是两台计算机上的两个进程之间的通信。</p>
<p>用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。本章主要介绍TCP和UDP编程。</p>
<span id="more"></span>

<h1 id="TCP-IP简介"><a href="#TCP-IP简介" class="headerlink" title="TCP&#x2F;IP简介"></a>TCP&#x2F;IP简介</h1><p>互联网协议包含了上百种协议标准，但是最重要的两个协议是TCP和IP协议，所以，大家把互联网的协议简称TCP&#x2F;IP协议。</p>
<p>IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1实际上是把32位整数按8位分组后的数字表示，目的是便于阅读。</p>
<p>一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。</p>
<h1 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h1><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>大多数连接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。</p>
<p>创建一个基于TCP连接的Socket，可以这样做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入socket库:</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket:</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="number">80</span>))</span><br></pre></td></tr></table></figure>

<p>创建<code>Socket</code>时，<code>AF_INET</code>指定使用<code>IPv4</code>协议，<code>SOCK_STREAM</code>指定使用面向流的TCP协议，这样，一个<code>Socket</code>对象就创建成功，但是还没有建立连接。</p>
<p>客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。IP地址可以通过域名dns解析获取到，端口号一般是固定80和443。</p>
<p>连接服务器的代码</p>
<blockquote>
<p>s.connect((‘<a href="http://www.baidu.com/">www.baidu.com</a>‘, 80))</p>
</blockquote>
<p>注意参数是一个<code>tuple</code>，包含地址和端口号。</p>
<p>建立TCP连接后，我们就可以向服务器发送请求，要求返回首页的内容：</p>
<h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。</p>
<p>一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。</p>
<p>是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。</p>
<p>我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上<code>Hello</code>再发回去。</p>
<p>首先，创建一个基于IPv4和TCP协议的Socket：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br></pre></td></tr></table></figure>

<p>然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。</p>
<p>端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用<code>8888</code>这个端口号。请注意，小于<code>1024</code>的端口号必须要有管理员权限才能绑定：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听端口:</span></span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8888</span>))</span><br></pre></td></tr></table></figure>
<p>紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Waiting for connection...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>接下来，服务器程序通过一个永久循环来接受来自客户端的连接，<code>accept()</code>会等待并返回一个客户端的连接:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接受一个新连接:</span></span><br><span class="line">    sock, addr = s.accept()</span><br><span class="line">    <span class="comment"># 创建新线程来处理TCP连接:</span></span><br><span class="line">    t = threading.Thread(target=tcplink, args=(sock, addr))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<p>每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tcplink</span>(<span class="params">sock, addr</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Accept new connection from %s:%s...&#x27;</span> % addr)</span><br><span class="line">    sock.send(<span class="string">b&#x27;Welcome!&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data <span class="keyword">or</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>) == <span class="string">&#x27;exit&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.send((<span class="string">&#x27;Hello, %s!&#x27;</span> % data.decode(<span class="string">&#x27;utf-8&#x27;</span>)).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    sock.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connection from %s:%s closed.&#x27;</span> % addr)</span><br></pre></td></tr></table></figure>
<p>连接建立后，服务器首先发一条欢迎消息，然后等待客户端数据，并加上<code>Hello</code>再发送给客户端。如果客户端发送了<code>exit</code>字符串，就直接关闭连接。</p>
<p>要测试这个服务器程序，我们还需要编写一个客户端程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 建立连接:</span></span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line"><span class="comment"># 接收欢迎消息:</span></span><br><span class="line"><span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> [<span class="string">b&#x27;Michael&#x27;</span>, <span class="string">b&#x27;Tracy&#x27;</span>, <span class="string">b&#x27;Sarah&#x27;</span>]:</span><br><span class="line">    <span class="comment"># 发送数据:</span></span><br><span class="line">    s.send(data)</span><br><span class="line">    <span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">s.send(<span class="string">b&#x27;exit&#x27;</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>我们需要打开两个命令行窗口，一个运行服务器程序，另一个运行客户端程序，就可以看到效果了</p>
<h1 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h1><p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。</p>
<p>使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。</p>
<p>虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。</p>
<p>和TCP类似，使用UDP的通信双方也分为客户端和服务器。服务器首先需要绑定端口：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定端口:</span></span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br></pre></td></tr></table></figure>

<p>创建Socket时，<code>SOCK_DGRAM</code>指定了这个Socket的类型是UDP。绑定端口和TCP一样，但是不需要调用<code>listen()</code>方法，而是直接接收来自任何客户端的数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Bind UDP on 9999...&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接收数据:</span></span><br><span class="line">    data, addr = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Received from %s:%s.&#x27;</span> % addr)</span><br><span class="line">    s.sendto(<span class="string">b&#x27;Hello, %s!&#x27;</span> % data, addr)</span><br></pre></td></tr></table></figure>
<p><code>recvfrom()</code>方法返回数据和客户端的地址与端口，这样，服务器收到数据后，直接调用<code>sendto()</code>就可以把数据用UDP发给客户端。</p>
<p>客户端使用UDP时，首先仍然创建基于UDP的Socket，然后，不需要调用<code>connect()</code>，直接通过<code>sendto()</code>给服务器发数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">100</span>)):</span><br><span class="line">    <span class="comment"># 发送数据:</span></span><br><span class="line">    s.sendto(<span class="built_in">str</span>(data).encode(<span class="string">&#x27;utf-8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line">    <span class="comment"># 接收数据:</span></span><br><span class="line">    <span class="built_in">print</span>(s.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>
<p>从服务器接收数据仍然调用<code>recv()</code>方法。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python访问数据库</title>
    <url>/python/python%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>主要介绍数据库的相关操作和SQLAlchemy框架</p>
<span id="more"></span>

<h1 id="使用SQLite"><a href="#使用SQLite" class="headerlink" title="使用SQLite"></a>使用SQLite</h1><p>Python就内置了SQLite3的驱动，可以直接使用</p>
<p>要操作关系数据库，首先需要连接到数据库，一个数据库连接称为<code>Connection</code>；</p>
<p>连接到数据库后，需要打开游标，称之为<code>Cursor</code>，通过<code>Cursor</code>执行SQL语句，然后，获得执行结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import sqlite3</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; conn = sqlite3.connect(<span class="string">&#x27;python.db&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor = conn.cursor()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.execute(<span class="string">&#x27;create table user (id int primary key, name varchar(20))&#x27;</span>)</span></span><br><span class="line">&lt;sqlite3.Cursor object at 0x0000027FCA51F740&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.execute(<span class="string">&#x27;insert into user values  (1, &quot;张三&quot;)&#x27;</span>)</span></span><br><span class="line">&lt;sqlite3.Cursor object at 0x0000027FCA51F740&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.rowcount</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.execute(<span class="string">&#x27;select * from user where name = &quot;张三&quot;&#x27;</span>)</span></span><br><span class="line">&lt;sqlite3.Cursor object at 0x0000027FCA51F740&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; value = cursor.fetchall()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; value</span></span><br><span class="line">[(1, &#x27;张三&#x27;)]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>Cursor</code>对象执行<code>insert</code>，<code>update</code>，<code>delete</code>语句时，执行结果由<code>rowcount</code>返回影响的行数，就可以拿到执行结果。</p>
<p>使用<code>Cursor</code>对象执行<code>select</code>语句时，通过<code>fetchall()</code>可以拿到结果集。结果集是一个<code>list</code>，每个元素都是一个<code>tuple</code>，对应一行记录。</p>
<p>如果SQL语句带有参数，那么需要把参数按照位置传递给<code>execute()</code>方法，有几个<code>?</code>占位符就必须对应几个参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; cursor.execute(<span class="string">&#x27;select * from user where id = ? or name = ?&#x27;</span>, (1, <span class="string">&#x27;李四&#x27;</span>))</span></span><br><span class="line">&lt;sqlite3.Cursor object at 0x0000027FCA51F6C0&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; value = cursor.fetchall()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; value</span></span><br><span class="line">[(1, &#x27;张三&#x27;), (2, &#x27;李四&#x27;)]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>要确保打开的<code>Connection</code>对象和<code>Cursor</code>对象都正确地被关闭，否则，资源就会泄露。</p>
<h1 id="使用MySql"><a href="#使用MySql" class="headerlink" title="使用MySql"></a>使用MySql</h1><p>需要安装驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install mysql-connector</span><br></pre></td></tr></table></figure>

<p>相关操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">conn = mysql.connector.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;root&#x27;</span>,database=<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;create table t_user(id int not null AUTO_INCREMENT primary key, name varchar(20))&#x27;</span>)</span><br><span class="line"><span class="comment"># 入库</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;insert into t_user values (%s, %s)&#x27;</span>, (<span class="number">1</span>, <span class="string">&#x27;张三&#x27;</span>))</span><br><span class="line">cursor.execute(<span class="string">&#x27;insert into t_user values (%s, %s)&#x27;</span>, (<span class="number">2</span>, <span class="string">&#x27;李四&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;执行结果&#x27;</span>, cursor.rowcount)</span><br><span class="line"></span><br><span class="line">conn.commit()</span><br><span class="line">cursor.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">cursor.execute(<span class="string">&#x27;select * from t_user where name = %s&#x27;</span>, (<span class="string">&#x27;张三&#x27;</span>, ))</span><br><span class="line">values = cursor.fetchall()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(values)</span><br><span class="line"><span class="built_in">print</span>(json.dumps(values, ensure_ascii=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>执行INSERT等操作后要调用<code>commit()</code>提交事务</p>
<p>MySQL的SQL占位符是<code>%s</code></p>
<h1 id="使用SQLAlchemy"><a href="#使用SQLAlchemy" class="headerlink" title="使用SQLAlchemy"></a>使用SQLAlchemy</h1><p>数据库表是一个二维表，包含多行多列。把一个表的内容用Python的数据结构表示出来的话，可以用一个list表示多行，list的每一个元素是tuple，表示一行记录，比如下面的记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  (1, &#x27;张三&#x27;), </span><br><span class="line">  (2, &#x27;李四&#x27;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Python的DB-API返回的数据结构就是像上面这样表示的</p>
<p>但是用tuple表示一行很难看出表的结构。如果把一个tuple用class实例来表示，就可以更容易地看出表的结构来，可以使用ORM框架进行转换，最有名的ORM框架是SQLAlchemy。</p>
<p>先安装 <code> pip install sqlalchemy</code></p>
<p>然后，利用上次我们在MySQL的test数据库中创建的<code>t_user</code>表，用SQLAlchemy来试试</p>
<p>第一步，导入SQLAlchemy，并初始化DBSession</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, INT, String, create_engine</span><br><span class="line"><span class="keyword">import</span> sqlalchemy</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象的基类:</span></span><br><span class="line">Base = sqlalchemy.orm.declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义user对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="comment"># 表的名字:</span></span><br><span class="line">    __tablename__ = <span class="string">&#x27;t_user&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 表的结构:</span></span><br><span class="line">    <span class="built_in">id</span> = Column(INT, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库连接:</span></span><br><span class="line">engine = create_engine(<span class="string">&#x27;mysql+mysqlconnector://root:root@localhost:3306/test&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建DBSession类型:</span></span><br><span class="line">DBSession = sessionmaker(bind=engine)</span><br><span class="line"><span class="built_in">print</span>(DBSession)</span><br></pre></td></tr></table></figure>

<p>以上代码完成SQLAlchemy的初始化和具体每个表的class定义。如果有多个表，就继续定义其他class</p>
<p><code>create_engine()</code>用来初始化数据库连接。SQLAlchemy用一个字符串表示连接信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;数据库类型+数据库驱动名称://用户名:口令@机器地址:端口号/数据库名&#x27;</span><br></pre></td></tr></table></figure>

<p>由于有了ORM，我们向数据库表中添加一行记录，可以视为添加一个<code>User</code>对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建session对象</span></span><br><span class="line">session = DBSession()</span><br><span class="line"><span class="comment"># 创建新User对象</span></span><br><span class="line">user1 = User(name=<span class="string">&#x27;Jim&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加到session</span></span><br><span class="line">session.add(user1)</span><br><span class="line"><span class="comment"># 提交即保存到数据库</span></span><br><span class="line">session.commit()</span><br><span class="line"><span class="comment"># 关闭session</span></span><br><span class="line">session.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关键是获取<code>session</code>，然后把对象添加到<code>session</code>，最后提交并关闭。<code>DBSession</code>对象可视为当前数据库连接</p>
<p>查询操作，查询出来的可以不再是<code>tuple</code>，而是<code>User</code>对象。SQLAlchemy提供的查询接口如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">session = DBSession()</span><br><span class="line"><span class="comment"># 创建Query查询，filter是where条件，最后调用one()返回唯一行，如果调用all()则返回所有行</span></span><br><span class="line">user2 = session.query(User).<span class="built_in">filter</span>(User.<span class="built_in">id</span> == <span class="number">2</span>).one()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;type:&#x27;</span>, <span class="built_in">type</span>(user2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>, user2.name)</span><br><span class="line"><span class="comment"># 查询多条</span></span><br><span class="line">user_list = session.query(User).<span class="built_in">filter</span>(User.<span class="built_in">id</span> &gt; <span class="number">0</span>).<span class="built_in">all</span>()</span><br><span class="line"><span class="built_in">print</span>(user_list)</span><br></pre></td></tr></table></figure>

<p>ORM就是把数据库表的行与相应的对象建立关联，互相转换。</p>
<h2 id="查询结果JSON序列化"><a href="#查询结果JSON序列化" class="headerlink" title="查询结果JSON序列化"></a>查询结果JSON序列化</h2><p>直接进行JSON序列化会报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TypeError: Object of type User is not JSON serializable</span><br></pre></td></tr></table></figure>

<p>使用 <code>default=lambda obj: obj.dict</code> 一样报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">print(json.dumps(user2, default=lambda obj: obj.dict, ensure_ascii=False))</span><br><span class="line"></span><br><span class="line">AttributeError: &#x27;User&#x27; object has no attribute &#x27;dict&#x27;</span><br></pre></td></tr></table></figure>

<p>正确的方式</p>
<p>使用 SQLAlchemy 对象进行 JSON 序列化时，可以使用 SQLAlchemy 提供的 <code>sqlalchemy.ext.declarative.as_declarative()</code> 装饰器和 <code>sqlalchemy.ext.declarative.declared_attr()</code> 装饰器来定义自定义的序列化方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@as_declarative()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line"><span class="meta">    @declared_attr</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__tablename__</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">return</span> cls.__name__.lower()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_dict</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;c.name: <span class="built_in">getattr</span>(self, c.name) <span class="keyword">for</span> c <span class="keyword">in</span> self.__table__.columns&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 序列化时改用 </span></span><br><span class="line"><span class="built_in">print</span>(json.dumps(user2.to_dict(), ensure_ascii=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python进程和线程</title>
    <url>/python/python%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>多任务操作系统，可以同时执行多个任务，单核CPU是通过进程调度，多个任务交替执行的。</p>
<p>一个任务就是一个进程，进程是操作系统分配资源的基本单位，具有独立的内存空间和资源，进程可以看做一个独立的程序，比如微信，qq等，一个进程可以包含多个线程，至少一个线程，线程是进程内的执行单位，共享进程的资源。</p>
<span id="more"></span>

<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Unix&#x2F;Linux 提供了 <code>fork()</code> 系统调用，调用一次返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>
<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。</p>
<p>Windows没有 <code>fork</code> 调用。</p>
<h2 id="multiprocessing"><a href="#multiprocessing" class="headerlink" title="multiprocessing"></a>multiprocessing</h2><p><code>multiprocessing</code> 模块是跨平台版本的多进程模块。</p>
<p><code>multiprocessing</code>提供了一个<code>Process</code>类来代表一个进程对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run child process %s (%s)...&#x27;</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Process(target=run_proc, args=(<span class="string">&#x27;子进程&#x27;</span>, ))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;启动子进程&#x27;</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程执行结束&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>
<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>
<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Process</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">long_time_task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (%s)...&#x27;</span> % (name, os.getpid()))</span><br><span class="line">    start = time.time()</span><br><span class="line">    time.sleep(random.random() * <span class="number">5</span>)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s runs %0.2f seconds.&#x27;</span> % (name, (end - start)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())</span><br><span class="line">    p = Pool(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p.apply_async(long_time_task, args=(i,))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocesses done...&#x27;</span>)</span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All subprocesses done.&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>解读：<br>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>
<p>由于<code>Pool</code>的默认大小是CPU的核数。如果任务数量大于Pool的大小，就需要等前面的任务执行完后才能执行后面的任务。</p>
<h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code>可以让我们方便的启动子进程，并控制其输入和输出。</p>
<p>如果子进程还需要输入，可以使用 <code>communicate()</code> 输入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nslookup www.baidu.com&#x27;</span>)</span><br><span class="line">r = subprocess.call([<span class="string">&#x27;nslookup&#x27;</span>, <span class="string">&#x27;www.baidu.com&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Exit code:&#x27;</span>, r)</span><br></pre></td></tr></table></figure>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>
<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process to write: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Process to read: %s&#x27;</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get(<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Get %s from queue.&#x27;</span> % value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line">    <span class="comment"># 启动子进程pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 启动子进程pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    <span class="comment"># 等待pw结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># pr进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    pr.terminate()</span><br></pre></td></tr></table></figure>

<p>在Unix&#x2F;Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。</p>
<p>由于Windows没有<code>fork</code>调用，因此，<code>multiprocessing</code>需要“模拟”出<code>fork</code>的效果，父进程所有Python对象都必须通过<strong>pickle序列化</strong>再传到子进程去，所以，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。Python的线程是真正的Posix Thread，而不是模拟出来的线程</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，<code>_thread</code>是低级模块，<code>threading</code>是高级模块，对<code>_thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>
<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行(和java有点像)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">task_run</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前线程名称是 %s&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    time.sleep(random.random() * <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;线程 % s 在执行任务&#x27;</span> % threading.current_thread().name)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;线程 %s 执行结束&#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;当前线程是 %s &#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br><span class="line">t = threading.Thread(target=task_run, name=<span class="string">&#x27;子线程&#x27;</span>)</span><br><span class="line">t.start()</span><br><span class="line">t.join()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;线程 %s 执行结束 &#x27;</span> % threading.current_thread().name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2…</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>线程共享变量，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容改乱了。</p>
<p>高级语言的一条语句在CPU执行时是若干条语句，即使一个简单的计算</p>
<blockquote>
<p>balance &#x3D; balance + n</p>
</blockquote>
<p>也分两步：</p>
<ol>
<li>计算balance + n，存入临时变量中；</li>
<li>将临时变量的值赋给balance。</li>
</ol>
<p>也就是可以看成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = balance + n</span><br><span class="line">balance = x</span><br></pre></td></tr></table></figure>

<p>两个线程同时一存一取，就可能导致余额不对，所以，我们必须确保一个线程在修改balance的时候，别的线程一定不能改。</p>
<p>如果我们要确保<code>balance</code>计算正确，就要给<code>change_it()</code>修改的地方上一把锁，当某个线程开始执行<code>change_it()</code>时，我们说，该线程因为获得了锁，因此其他线程不能同时执行<code>change_it()</code>，只能等待，直到锁被释放后，获得该锁以后才能改。</p>
<p>由于锁只有一个，无论多少线程，同一时刻最多只有一个线程持有该锁，所以，不会造成修改的冲突。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>
<p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，其他线程需要继续等待，执行完后需要释放锁，可以放到<code>try...finally</code>代码块中来确保一定释放。</p>
<h2 id="多核CPU"><a href="#多核CPU" class="headerlink" title="多核CPU"></a>多核CPU</h2><p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。</p>
<p>但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>
<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：<code>Global Interpreter Lock</code>，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>
<p>在Python中，可以使用多线程，但不要指望能有效利用多核。</p>
<p>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>多线程环境下，尽量使用局部变量，全局变量的修改操作需要加锁。但是局部变量在函数调用时传递比较麻烦。</p>
<p>正常情况下，需要函数一层层往下传递，比较麻烦，也可以使用全局变量dict来保存，使用线程信息作为key，代码看起来比较乱。可以使用 <code>ThreadLocal</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lc = threading.local()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_info</span>():</span><br><span class="line">    name = lc.user</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前线程 %s 输出用户名 %s&#x27;</span> % (threading.current_thread(), name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">name</span>):</span><br><span class="line">    lc.user = name</span><br><span class="line">    time.sleep(random.random() * <span class="number">3</span>)</span><br><span class="line">    print_info()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    t = threading.Thread(target=set_info, args=(i,), name=<span class="string">&#x27;thread-&#x27;</span> + <span class="built_in">str</span>(i))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以理解为全局变量<code>lc</code>是一个<code>dict</code>，不但可以用<code>lc.user</code>，还可以绑定其他变量，如<code>lc.job</code>等等。</p>
<p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>
<p>一个<code>ThreadLocal</code>变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。<code>ThreadLocal</code>解决了参数在一个线程中各个函数之间互相传递的问题。</p>
<h1 id="进程-vs-线程"><a href="#进程-vs-线程" class="headerlink" title="进程 vs. 线程"></a>进程 vs. 线程</h1><p><strong>线程切换</strong></p>
<p>多任务线程切换。</p>
<p><strong>计算密集型 vs. IO密集型</strong></p>
<p>计算密集型主要消耗CPU资源，减少线程数，减少线程切换。 IO密集型主要消耗在IO等待，任务数提升，可以提高CPU的利用率。如常见的web应用。</p>
<p><strong>异步IO</strong></p>
<p>CPU和IO有巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行。</p>
<p>现在操作系统一般都支持异步IO，如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。</p>
<p>对应到Python语言，单线程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</p>
<h1 id="分布式进程"><a href="#分布式进程" class="headerlink" title="分布式进程"></a>分布式进程</h1><p>在Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p>
<p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>
<p><code>QueueManager</code>的使用。可以把任务分布到多台机器上进行就算。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python错误和调试</title>
    <url>/python/python%E9%94%99%E8%AF%AF%E5%92%8C%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<p>在程序运行过程中，总会遇到各种各样的错误。有代码逻辑错误，有运行时错误，有用户输入错误等。</p>
<p>此外，还可以通过使用<code>pdb</code>进行调试。</p>
<span id="more"></span>


<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="try"><a href="#try" class="headerlink" title="try"></a>try</h2><p>python提供了 <code>try...except...finally...</code> 来处理异常。</p>
<p>不同的错误类型，可以由不同的<code>except</code>来处理。 <code>finally</code> 可以没有。</p>
<p>如果没有错误发生，可以在except语句块后面加一个<code>else</code>，当没有错误发生时，会自动执行<code>else</code>语句</p>
<p>错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，捕获父类之后，下面捕获子类的代码就不会执行到了。 和java类似。</p>
<p>python常见的错误类型和继承关系 <a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">exception-hierarchy</a></p>
<p>示例如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">error_test</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;try...&#x27;</span>)</span><br><span class="line">        result = <span class="number">10</span> / <span class="built_in">int</span>(num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;结果是 %s&#x27;</span> % result)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> ve:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ValueError: &#x27;</span>, ve )</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> zde:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivisionError: &#x27;</span>, zde)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;无异常&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;finally...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">error_test(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">error_test(<span class="number">2</span>)</span><br><span class="line">error_test(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">error_test(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>如下面错误的堆栈信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;err.py&quot;, line 11, in &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File &quot;err.py&quot;, line 9, in main</span><br><span class="line">    bar(&#x27;0&#x27;)</span><br><span class="line">  File &quot;err.py&quot;, line 6, in bar</span><br><span class="line">    return foo(s) * 2</span><br><span class="line">  File &quot;err.py&quot;, line 3, in foo</span><br><span class="line">    return 10 / int(s)</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Traceback (most recent call last):</p>
</blockquote>
<p>第一行，告诉我们这是错误的跟踪信息。 后面可以逐行分析， 最终找到错误的根源。</p>
<blockquote>
<p>出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。</p>
</blockquote>
<h2 id="记录错误"><a href="#记录错误" class="headerlink" title="记录错误"></a>记录错误</h2><p><code>logging</code> 模块可以记录错误信息。</p>
<p>捕获错误，然后记录错误堆栈信息，让程序继续往下运行。</p>
<h2 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h2><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p>
<p>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如<code>ValueError</code>，<code>TypeError</code>），尽量使用Python内置的错误类型。</p>
<p>我们还可以捕获异常，记录之后将异常重新抛出，也可以转换为其他异常(要符合逻辑，不能随意转换)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ValueError!&#x27;</span>)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">10</span> / <span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">&#x27;input error!&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>程序也可以主动抛出错误，让调用者来处理相应的错误。但是，应该在文档中写清楚可能会抛出哪些错误，以及错误产生的原因。</p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="print"><a href="#print" class="headerlink" title="print"></a>print</h2><p>使用<code>print()</code>将相关变量的值打印出来，但是将来还需要删除它。</p>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>凡是用<code>print()</code>来辅助查看的地方，都可以用断言<code>（assert）</code>来替代：</p>
<blockquote>
<p>assert n !&#x3D; 0, ‘n is zero!’</p>
</blockquote>
<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p>
<p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code></p>
<p>启动Python解释器时可以用<code>-O</code>(大写的英文O)参数来关闭<code>assert</code>， 关闭后 <code>assert</code> 可以当做 <code>pass</code></p>
<h2 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h2><p>把<code>print()</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=logging.INFO)</span><br></pre></td></tr></table></figure>

<p><code>logging</code> 可以控制日志的级别， 有<code>debug</code>，<code>info</code>，<code>warning</code>，<code>error</code>, 也可以通过配置，将日志输出到不同的地方。</p>
<h2 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h2><p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。</p>
<p>以参数<code>-m pdb</code> 启动后，pdb定位到下一步要执行的代码，可以输入命令 <code>l</code>(小写的L) 来查看代码。输入命令<code>n</code>可以单步的执行代码。</p>
<p>可以输入<code>p 变量名</code>来查看变量。输入命令<code>q</code> 来结束调试。</p>
<h2 id="pdb-set-trace"><a href="#pdb-set-trace" class="headerlink" title="pdb.set_trace()"></a>pdb.set_trace()</h2><p><code>pdb</code> 单步执行太麻烦，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># err.py</span></span><br><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;0&#x27;</span></span><br><span class="line">n = <span class="built_in">int</span>(s)</span><br><span class="line">pdb.set_trace() <span class="comment"># 运行到这里会自动暂停</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">10</span> / n)</span><br></pre></td></tr></table></figure>
<p>运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入<code>pdb</code>调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行</p>
<h2 id="IDE调试"><a href="#IDE调试" class="headerlink" title="IDE调试"></a>IDE调试</h2><p>VS Code 插件。</p>
<p>虽然用IDE调试起来比较方便，但是最后你会发现，logging才是终极武器。</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>
<p>单元测试通过后，如果对代码做了修改，可以重新跑一遍单元测试，看是否通过，来判断修改是否对原来的逻辑造成了影响。</p>
<p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承</p>
<p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p>
<p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，最常用的断言就是<code>assertEqual()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.assertEqual(<span class="built_in">abs</span>(-<span class="number">1</span>), <span class="number">1</span>) <span class="comment"># 断言函数返回的结果与1相等</span></span><br></pre></td></tr></table></figure>

<p>另一种重要的断言就是期待抛出指定类型的Error</p>
<p><strong>运行单元测试</strong></p>
<p>最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码，这样就可以把文件当做正常脚本运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<p>另一种方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试。</p>
<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试</p>
<p><strong>setUp与tearDown</strong></p>
<p>可以在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。</p>
<p><code>setUp()</code>和<code>tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码</p>
<p>类似 java单元测试中的 <code>@Before</code> 和 <code>@After</code></p>
<h1 id="文档测试"><a href="#文档测试" class="headerlink" title="文档测试"></a>文档测试</h1><p>Python官方文档中的示例代码，比如 <a href="https://docs.python.org/3/library/re.html">re模块</a> 就带了很多示例代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import re</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m = re.search(<span class="string">&#x27;(?&lt;=abc)def&#x27;</span>, <span class="string">&#x27;abcdef&#x27;</span>)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; m.group(0)</span></span><br><span class="line">&#x27;def&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>
<p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。</p>
<p>既然这些代码本身就可以粘贴出来直接运行，也可以自动执行写在注释中的这些代码。</p>
<p>当我们编写注释时，如果写上这样的注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">abs</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Function to get absolute value of number.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Example:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(-1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; abs(0)</span></span><br><span class="line"><span class="string">    0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> n <span class="keyword">if</span> n &gt;= <span class="number">0</span> <span class="keyword">else</span> (-n)</span><br></pre></td></tr></table></figure>

<p>可以明确地告诉函数的调用者该函数的期望输入和输出</p>
<p>并且，Python内置的“文档测试”（<code>doctest</code>）模块可以直接提取注释中的代码并执行测试。</p>
<p>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用…表示中间一大段烦人的输出。</p>
<p>示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Calculate 1*2*...*n</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(1)</span></span><br><span class="line"><span class="string">    1</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(10)</span></span><br><span class="line"><span class="string">    3628800</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; fact(-1)</span></span><br><span class="line"><span class="string">    Traceback (most recent call last):</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">    ValueError</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError()</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numList = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> numList:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s的阶乘结果是%s&#x27;</span> % (i  ,fact(i) ))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>doctest不仅可以用来测试，还可以直接作为示例代码，通过某些文档生成工具，可以自动把包含doctest的注释提取出来。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python面向对象高级编程</title>
    <url>/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，下面会讨论多重继承、定制类、元类等概念。</p>
<span id="more"></span>

<h1 id="使用-slots"><a href="#使用-slots" class="headerlink" title="使用 slots"></a>使用 <strong>slots</strong></h1><p>正常情况下，可以给一个类的实例创建任何属性和方法，这就是动态语言的灵活性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>绑定属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = Student()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 动态给实例绑定一个属性</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(s.name)</span></span><br><span class="line">Michael</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也可以绑定一个方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def set_age(self, age): <span class="comment"># 定义一个函数作为实例方法</span></span></span><br><span class="line">...     self.age = age</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from types import MethodType</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.set_age = MethodType(set_age, s) <span class="comment"># 给实例绑定一个方法</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.set_age(25) <span class="comment"># 调用实例方法</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.age <span class="comment"># 测试结果</span></span></span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<p>给实例绑定的方法，对另一个实例无效，所以可以绑定到类上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def set_score(self, score):</span></span><br><span class="line">...     self.score = score</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Student.set_score = set_score</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，上面的<code>set_score</code>方法可以直接定义在class中，但动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p>
<p><strong>使用__slots__</strong></p>
<p>如果我们想要限制实例的属性怎么办？比如，只允许对<code>Student</code>实例添加<code>name</code>和<code>age</code>属性。</p>
<p>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性：</p>
<p><code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的。子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。</p>
<p>验证如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p1 = Person()</span><br><span class="line">p1.name = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p1.name)</span><br><span class="line"><span class="comment"># 添加score属性会报错</span></span><br><span class="line"><span class="comment">#p1.score = 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;class&#x27;</span>, <span class="string">&#x27;score&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s1 = Student()</span><br><span class="line"></span><br><span class="line">s1.name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">s1.age = <span class="string">&#x27;14&#x27;</span></span><br><span class="line">s1.score = <span class="number">98</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1.name, s1.age, s1.score)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用-property"><a href="#使用-property" class="headerlink" title="使用@property"></a>使用@property</h1><p>如果给属性加上访问限制，使用get set方法，也可以在赋值时检查数据的合理性。这样操作略显复杂。</p>
<p>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的</p>
<p>把一个getter方法变成属性，只需要加上<code>@property</code>就可以了。我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br></pre></td></tr></table></figure>
<p>只定义getter方法，不定义setter方法就是一个只读属性，上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p>
<p>要特别注意：属性的方法名不要和实例变量重名，下面的就是错误的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法名称和实例变量均为birth:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.birth</span><br></pre></td></tr></table></figure>

<p>这是因为调用<code>s.birth</code>时，首先转换为方法调用，在执行<code>return self.birth</code>时，又视为访问<code>self</code>的属性，于是又转换为方法调用，造成无限递归，最终导致栈溢出报错<code>RecursionError</code></p>
<h1 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h1><p>如果是单继承的话，层级结构如下。</p>
<pre class="mermaid">graph TD
动物 --> 会飞的
动物 --> 会跑的
会飞的 --> 鹦鹉
会飞的 --> 老鹰
会跑的 --> 狗
会跑的 --> 猫</pre>
<p>如果需要再添加新的继承关系，就会很复杂了， 所以可以采用多重继承的方式。 比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(Mammal, Runnable):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>
<p><strong>MixIn</strong></p>
<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>MixIn</code>。</p>
<p>MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。</p>
<p>由于Python允许使用多重继承，因此，MixIn就是一种常见的设计。</p>
<p>java中只允许单继承，但是可以通过 implements 多个接口来实现类似的功能。</p>
<h1 id="定制类"><a href="#定制类" class="headerlink" title="定制类"></a>定制类</h1><p>看到类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>
<p><code>__slots__</code> 用于限制实例的属性</p>
<p><code>__len__()</code> 让类作用于<code>len()</code>函数</p>
<p>Python的class中还有许多这样有特殊用途的函数，可以帮助我们定制类。</p>
<p><code>__str__</code></p>
<p>类似java的 <code>toString()</code>方法， 自定义对象的输出信息。可以将实例内部的信息输出。</p>
<p><code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串(对象的内存地址信息等),比如<code>&lt;__main__.Student object at 0x000001A342D19F70&gt;</code>，也就是说 <code>__repr__()</code>是为调试服务的。</p>
<p><code>__iter__</code></p>
<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list</code>或<code>tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>__next__()</code>方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 初始化两个计数器a，b</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self <span class="comment"># 实例本身就是迭代对象，故返回自己</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        self.a, self.b = self.b, self.a + self.b <span class="comment"># 计算下一个值</span></span><br><span class="line">        <span class="keyword">if</span> self.a &gt; <span class="number">100000</span>: <span class="comment"># 退出循环的条件</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line">        <span class="keyword">return</span> self.a <span class="comment"># 返回下一个值</span></span><br></pre></td></tr></table></figure>

<p><code>__getitem__</code></p>
<p>如果需要像list那样按照下标取元素，就需要实现<code>__getitem__()</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fib</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, n</span>):</span><br><span class="line">        a, b = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>

<p>如果把对象看成<code>dict</code>，<code>__getitem__()</code>的参数也可能是一个可以作key的object，例如<code>str</code></p>
<p>与之相对应的是 <code>__setitem__()</code>，把对象当做list或者dict来进行赋值，<code>__delitem__()</code> 用于删除某个元素。</p>
<p><code>__getattr__</code></p>
<p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。Python提供了一个机制，那就是写一个<code>__getattr__()</code>方法，动态返回一个属性或者函数。</p>
<p>这就可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。</p>
<p>这种特性可以用来针对完全动态的情况作调用。比如 url中的动态路径。</p>
<p><code>__call__</code></p>
<p>我们用<code>instance.method()</code>来调用对象的方法，也可以在实例本身上调用，需要定义一个<code>__call__()</code>方法即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;My name is %s.&#x27;</span> % self.name)</span><br></pre></td></tr></table></figure>

<p><code>__call__()</code>还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样。</p>
<p>如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。</p>
<p>判断一个对象是否能被调用，能被调用的对象就是一个<code>Callable</code>对象，通过<code>callable()</code> 函数判断对象是否是”可调用”的对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; callable(str)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; callable(int)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; callable(None)</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; callable((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h1><p>当我们定义常量时，简单的方法是用大写变量通过常数来定义，但是缺点是类型是<code>int</code>， 并且依然是变量。</p>
<p>更好的方法是使用<code>Enum</code>来定义一个枚举类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>Month.Jan</code>来引用一个常量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br></pre></td></tr></table></figure>

<p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p>
<p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>访问方式有下面几种</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(Weekday.Sun)</span></span><br><span class="line">Weekday.Sun</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(Weekday[<span class="string">&#x27;Sun&#x27;</span>])</span></span><br><span class="line">Weekday.Sun</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(Weekday(1))</span></span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(Weekday(1).value)</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; day1 = Weekday.Sun</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day1 == Weekday(1))</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day1 == Weekday(0))</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day1 == Weekday[<span class="string">&#x27;Sun&#x27;</span>])</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(day1 == Weekday.Sun)</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h1><blockquote>
<p>元类就是深度的魔法，99% 的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。</p>
</blockquote>
<p><strong>type()</strong></p>
<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p>
<p>比方说我们要定义一个<code>Hello</code>的class，就写一个<code>hello.py</code>模块：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">class Hello(object):</span><br><span class="line">    def hello(self, name=&#x27;world&#x27;):</span><br><span class="line">        print(&#x27;Hello, %s.&#x27; % name)</span><br></pre></td></tr></table></figure>

<p>当Python解释器载入<code>hello</code>模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个<code>Hello</code>的class对象，测试如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from hello import Hello</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; h = Hello()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; h.hello()</span></span><br><span class="line">Hello, world.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(Hello))</span></span><br><span class="line">&lt;class &#x27;type&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(h))</span></span><br><span class="line">&lt;class &#x27;hello.Hello&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是class <code>Hello</code>。</p>
<p>我们说class的定义是运行时动态创建的，而创建class的方法就是使用<code>type()</code>函数。</p>
<p><strong>metaclass</strong></p>
<p>除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。</p>
]]></content>
  </entry>
  <entry>
    <title>python面向对象编程</title>
    <url>/python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。</p>
<span id="more"></span>

<h1 id="OOP概念"><a href="#OOP概念" class="headerlink" title="OOP概念"></a>OOP概念</h1><p>OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>
<p>面向过程的程序设计把计算机程序视为一系列的命令集合，即一组函数的顺序执行。</p>
<p>OOP设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<p>下面举例说明面向过程和面向对象的在程序流程上的不同。</p>
<p>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个dict表示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">std1 = &#123; &#x27;name&#x27;: &#x27;Michael&#x27;, &#x27;score&#x27;: 98 &#125;</span><br><span class="line">std2 = &#123; &#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;score&#x27;: 81 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">def print_score(std):</span><br><span class="line">    print(&#x27;%s: %s&#x27; % (std[&#x27;name&#x27;], std[&#x27;score&#x27;]))</span><br></pre></td></tr></table></figure>
<p>如果采用OOP的设计思想，首先思考的不是程序的执行流程，而是 <code>Student</code> 这种数据类型应该被视为一个对象。这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure>
<p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line">lisa = Student(<span class="string">&#x27;Lisa Simpson&#x27;</span>, <span class="number">87</span>)</span><br><span class="line">bart.print_score()</span><br><span class="line">lisa.print_score()</span><br></pre></td></tr></table></figure>

<p>类（Class）和实例（Instance）, Class是一种抽象概念，比如我们定义的Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的Student，比如，Bart Simpson和Lisa Simpson是两个具体的Student。</p>
<p>所以，面向对象的设计思想是抽象出Class，根据Class创建Instance。</p>
<p>面向对象的抽象程度又比函数要高，因为一个Class既包含数据，又包含操作数据的方法。</p>
<p>封装，继承，多态，三大特点，和java一样。</p>
<h1 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h1><p>面向对象最重要的概念就是类（Class）和实例（Instance），类是抽象的模板。</p>
<p>在Python中，定义类是通过<code>class</code>关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p>
<p>定义好了类，就可以通过类创建出实例。创建实例是通过类名+()实现的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Student</span></span><br><span class="line">&lt;class &#x27;__main__.Student&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s = Student()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s</span></span><br><span class="line">&lt;__main__.Student object at 0x000001A965ADA690&gt;</span><br></pre></td></tr></table></figure>

<p>实例创建后可以自由地给实例变量绑定属性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.name = <span class="string">&#x27;张三&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s.name</span></span><br><span class="line">&#x27;张三&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特殊方法“__init__”前后分别有两个下划线！！！</p>
</blockquote>
<p><code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p>
<p>有了<code>__init__</code>方法，在创建实例的时候，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code>不需要传，Python解释器自己会把实例变量传进去：</p>
<p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。</p>
<p><strong>数据封装</strong></p>
<p>封装通过将数据和对数据的操作（方法）捆绑在一起，形成一个独立的、可复用的单位，对外部隐藏内部实现细节，只暴露出简单的接口供其他代码使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; class Student(object):</span></span><br><span class="line">...   def hello(self):</span><br><span class="line">...     print(&#x27;hello&#x27;)</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s1 = Student()</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s1.hello</span></span><br><span class="line">&lt;bound method Student.hello of &lt;__main__.Student object at 0x0000015DEB716B10&gt;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; s1.hello()</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure>
<p>通过实例变量访问方法时，如果不加括号，输出的是方法的信息，要调用方法必须要加上<code>()</code></p>
<h1 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h1><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p>
<p>这样就确保外部无法随意修改对象内部的状态。</p>
<p>如果想要访问或者修改对象内部的数据，可以给类增加 get 和 set 方法， 和java类似。可以在方法中对参数做校验。</p>
<p>变量名类似<code>__xxx__</code>的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用<code>__name__</code>、<code>__score__</code>这样的变量名。</p>
<p>以一个下划线开头的实例变量名，比如<code>_name</code>，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，这样的变量不能随意访问。</p>
<p>Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量，但是强烈不建议这么做。</p>
<h1 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h1><p><strong>继承</strong></p>
<p>当我们定义一个class时，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）</p>
<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。继承可以实现代码的重用和扩展。</p>
<p><strong>多态</strong></p>
<p>子类重写父类方法。</p>
<p>子类的实例的数据类型也可以看做是父类的数据类型，反过来不行。</p>
<p>多态的好处，当函数需要接收子类时，只需要定义时接收父类就行。调用函数时，可以传入不同的子类的实例。</p>
<blockquote>
<p>java中叫 父类引用指向子类对象？</p>
</blockquote>
<p><strong>静态语言 vs 动态语言</strong></p>
<p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p>
<p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p>
<p>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</p>
<p>Python的“file-like object“就是一种鸭子类型。</p>
<h1 id="获取对象信息"><a href="#获取对象信息" class="headerlink" title="获取对象信息"></a>获取对象信息</h1><p><strong>type()</strong></p>
<p>使用 <code>type()</code> 方法， 可以判断某个对象是什么类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(11)</span></span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L=[1,2,3,4]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(L)</span></span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(<span class="string">&#x27;aa&#x27;</span>)</span></span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; def func():</span></span><br><span class="line">...   pass</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(func())</span></span><br><span class="line">&lt;class &#x27;NoneType&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(func)</span></span><br><span class="line">&lt;class &#x27;function&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="built_in">type</span>(abs)</span></span><br><span class="line">&lt;class &#x27;builtin_function_or_method&#x27;&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>type()</code> 返回的是对象的Class类型。可以进行 <code>==</code> 比较，判断是否是相同的类。</p>
<p><strong>使用isinstance()</strong></p>
<p>如果有继承关系，使用<code>type()</code> 就不方便判断了， 可以使用 <code>isinstance()</code></p>
<p><code>isinstance()</code>判断的是一个对象是否是该类型本身，或者位于该类型的父继承链上。</p>
<p>能用<code>type()</code>判断的基本类型也可以用<code>isinstance()</code>判断。并且还可以判断一个变量是否是某些类型中的一种。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance([1,2,3], (list, tuple))</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance([1,2,3], (dict, tuple))</span></span><br><span class="line">False</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), (set, tuple))</span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以可以优先使用 <code>isinstance()</code>来判断类型。</p>
<p><strong>使用dir()</strong></p>
<p>使用<code>dir()</code> 方法可以获取一个对象的所有属性和方法，返回的是一个包含字符串的list。</p>
<p>仅仅把属性和方法列出来是不够的，配合<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>，我们可以直接操作一个对象的状态</p>
<p>如果试图获取不存在的属性，会抛出AttributeError的错误， 可以在方法中加上默认值。 例如：<code>getattr(obj, &#39;z&#39;, 404)</code></p>
<p>也可以使用 <code>hasattr()</code>，<code>getattr()</code> 判断和获取对象的方法。</p>
<h1 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h1><p>给实例绑定属性的方法是通过实例变量，或者通过self变量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">s.score = <span class="number">90</span></span><br></pre></td></tr></table></figure>

<p>但是，如果<code>Student</code>类本身需要绑定一个属性呢？可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>类所有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br></pre></td></tr></table></figure>

<p>类属性，类的所有实例都可以访问到。和java中继承很相似。</p>
<p>在编写程序的时候，千万不要对实例属性和类属性使用相同的名字，避免出现错误。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python高级特性</title>
    <url>/python/python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>主要介绍切片，迭代，列表生成式，生成器，迭代器等高级特性。</p>
<span id="more"></span>

<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>取一个list或tuple的部分元素，对于指定索引范围的操作，python提供了切片(Slice)操作符。</p>
<p>比如一个list如下</p>
<blockquote>
<p>L&#x3D;[1,2,3,4,5,6,7,8,9]</p>
</blockquote>
<p>可以如下操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0:4]</span></span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p><code>L[0:4]</code> 表示 从索引<code>0</code> 开始，直到索引<code>4</code> 未知，不包含结尾的索引<code>4</code> ， 所以取的是索引位置  <code>0</code> <code>1</code> <code>2</code> <code>3</code> 对应的元素。</p>
<p>如果第一个索引位置是0 ， 也可以省略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:2]</span></span><br><span class="line">[1, 2]</span><br></pre></td></tr></table></figure>
<p>python支持按照倒序通过索引获取元素，同样也支持按照倒序进行切片。 倒序的第一个索引是 <code>-1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[-2:]</span></span><br><span class="line">[8, 9]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[-4:-2]</span></span><br><span class="line">[6, 7]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0:-2]</span></span><br><span class="line">[1, 2, 3, 4, 5, 6, 7]</span><br></pre></td></tr></table></figure>

<p>也可以对空集合进行切片, 对空集合直接只用索引访问会报错，但是切片不会。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L=[]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0]</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">IndexError: list index out of range</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0:]</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[0:1]</span></span><br><span class="line">[]</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:1]</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>使用场景</p>
<p>比如创建一个0-99的数列。</p>
<blockquote>
<p>L&#x3D;list(range(100))</p>
</blockquote>
<p>取前10个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:10]</span></span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>后10个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[-10:]</span></span><br><span class="line">[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]</span><br></pre></td></tr></table></figure>
<p>前10个数，每两个取一个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:10:2]</span></span><br><span class="line">[0, 2, 4, 6, 8]</span><br></pre></td></tr></table></figure>
<p>所有数，每5个取一个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[::5]</span></span><br><span class="line">[0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]</span><br></pre></td></tr></table></figure>

<p>只写 <code>[:]</code> 原样复制一个list</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; L[:]</span></span><br><span class="line">[0, 1, 2, 3, ..., 99]</span><br></pre></td></tr></table></figure>
<p>tuple 也可以做上述操作，只是tuple切片的结果依然是tuple。</p>
<p>字符串 <code>xxxxx</code> 也可以看成是一种list，每个元素就是一个字符,  也可以进行切片。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abcdefg&#x27;</span>[0:1]</span></span><br><span class="line">&#x27;a&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abcdefg&#x27;</span>[2:]</span></span><br><span class="line">&#x27;cdefg&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abcdefg&#x27;</span>[::]</span></span><br><span class="line">&#x27;abcdefg&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="string">&#x27;abcdefg&#x27;</span>[::3]</span></span><br><span class="line">&#x27;adg&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>通过for循环来遍历集合，成为迭代。</p>
<p>在python中， 迭代是通过 <code>for ... in</code>  来完成的。和 java的迭代类似。</p>
<p>dict的迭代</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">迭代 key</span></span><br><span class="line">d = &#123;&quot;k1&quot;:&quot;v1&quot;, &quot;k2&quot; : &quot;v2&quot;, &quot;k3&quot;:&quot;v3&quot;&#125;</span><br><span class="line">for k in d:</span><br><span class="line">    print(k)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">迭代value</span></span><br><span class="line">for v in d.values():</span><br><span class="line">    print(v)</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同时迭代 key和value</span></span><br><span class="line">for k, v in d.items():</span><br><span class="line">    print(k, v)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>dict 默认迭代的是 <code>key</code>， 迭代出的顺序可能不一样。</p>
<p>字符串也可以进行迭代，输出每一个字符。  </p>
<p>只要一个对象是可迭代的， <code>for</code> 循环就可以运行。</p>
<p>通过 <code>collections.abc</code> 模块的 <code>Iterable</code> 判断对象是否是可迭代的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from collections.abc import Iterable</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance(<span class="string">&#x27;abc&#x27;</span>, Iterable) <span class="comment"># str是否可迭代</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance([1,2,3], Iterable) <span class="comment"># list是否可迭代</span></span></span><br><span class="line">True</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; isinstance(123, Iterable) <span class="comment"># 整数是否可迭代</span></span></span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>对list使用下标循环， 可以使用 <code>enumerate</code> 将list转换为 索引-元素对</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">L=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><span class="line">for i, v in enumerate(L):</span><br><span class="line">    print(i, v) </span><br></pre></td></tr></table></figure>

<h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>要生成list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code> 可以用<code>list(range(1, 11))</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; list(range(1, 11))</span></span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>
<p>生成 <code>[1x1, 2x2, 3x3, ..., 10x10]</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(1, 11)]</span></span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span><br></pre></td></tr></table></figure>
<p>把要生成的元素<code>x*x</code> 放在前面， 后面跟上 <code>for</code> 循环。 </p>
<p>for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(1, 11) <span class="keyword">if</span> x % 2 == 0]</span></span><br><span class="line">[4, 16, 36, 64, 100]</span><br></pre></td></tr></table></figure>

<p><strong>if else</strong></p>
<p>列表生成式， for 后面的<code>if</code> 是筛选条件， 所以不能加上 <code>else</code>， 否则无法筛选。</p>
<p><code>for</code> 前面的<code>if</code> 是表达式， 必须加上else </p>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>列表生成式，直接把元素都创建出来了，会占用内存，数量也会受到内存的限制。</p>
<p>所以，如果元素按照某种算法推算出来，在循环中不断推算出后面的元素，就不必创建完整的list， 这种一边循环一边计算的机制，称为生成器 generator</p>
<p>创建 generator 有很多种方法，可以把生成式的 <code>[]</code> 改成 <code>()</code> ，就创建了一个 generator</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(10))</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; g</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x000001A96593F780&gt;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; <span class="keyword">for</span> i <span class="keyword">in</span> g:</span></span><br><span class="line">...   print(i)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以调用 <code>next(g)</code> 方法获取下一个元素， 也可以使用for 循环进行迭代。</p>
<p>要把普通函数改造成 generator函数，需要加上 <code>yield</code> 关键字。</p>
<p>generator函数在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p>
<p><strong>调用generator函数会创建一个generator对象，多次调用generator函数会创建多个相互独立的generator。</strong></p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>可以直接作用于<code>for</code> 循环的对象，统称为可迭代对象<code>Iterable</code></p>
<p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>. 可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象</p>
<p>把<code>list</code> <code>dict</code>  <code>str</code> 等 <code>Iterable</code>变成 <code>Iterator</code> 可以使用 <code>iter()</code> 函数。 和java 的<code>iterator()</code>方法类似。</p>
<p><code>Iterator</code>对象表示的是一个数据流， Iterator对象可以不断被<code>next()</code>函数调用并返回下一个数据，计算是惰性的，只有在需要返回下一个对象时才进行计算。</p>
<p><code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime使用</title>
    <url>/tools/SublimeText%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="配置，安装插件"><a href="#配置，安装插件" class="headerlink" title="配置，安装插件"></a>配置，安装插件</h2><ol>
<li>常用的package，以及配置，参考<a href="https://github.com/cpf929/Users.git">Users目录的配置文件</a></li>
</ol>
<span id="more"></span>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>可以直接打开图片</li>
<li>Goto Anything功能 — 快速查找（ctrl + P）</li>
</ol>
<ul>
<li>输入@+函数名可以快速找到函数。</li>
<li>输入#+文本可以快速进行文件内文本匹配</li>
<li>在打开文件夹的情况下，输入文件名，可以模糊匹配包含对应字符的文件。</li>
<li>在打开文件夹的情况下，文件名 + ：+ 行号，跳转到对应的行， 文件名 + @ 可以跳转到对应的代码段</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>快捷键一般都可以在ST的菜单中找到。</p>
<ol>
<li>快速复制当前行 CTRL + SHIFT + D</li>
<li>删除当前行 CTRL + SHIFT + K</li>
</ol>
]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docsify搭建github pages页面</title>
    <url>/tools/docsify-config/</url>
    <content><![CDATA[<p>docsify 可以快速帮你生成文档网站。不同于 GitBook、Hexo 的地方是它不会生成静态的 <code>.html</code> 文件，<br>所有转换工作都是在运行时。如果你想要开始使用它，只需要创建一个 <code>index.html</code> 就可以开始编写文档并直接部署在 GitHub Pages。</p>
<span id="more"></span>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>可以直接参考官方文档 <a href="https://docsify.js.org/#/zh-cn/quickstart">快速开始</a></p>
<p>效果参考  <a href="https://cpfe.github.io/#/">docsify页面</a></p>
<h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Description&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.sidebar-nav</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-class">.file</span> <span class="selector-tag">p</span> &gt; <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">15px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: <span class="number">700</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="number">#364149</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.sidebar-nav</span> <span class="selector-class">.folder</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">cursor</span>: pointer;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    加载中</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">$docsify</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>: <span class="string">&#x27;文档&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">repo</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">loadSidebar</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">subMaxLevel</span>: <span class="number">2</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">coverpage</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">onlyCover</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">auto2top</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">mergeNavbar</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">alias</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="string">&#x27;/_sidebar.md&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">count</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">countable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">fontsize</span>: <span class="string">&#x27;0.9em&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">color</span>: <span class="string">&#x27;rgb(90,90,90)&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">language</span>: <span class="string">&#x27;chinese&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// docsify-pagination</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">pagination</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">crossChapter</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">crossChapterText</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">search</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">maxAge</span>: <span class="number">86400000</span>, <span class="comment">// 过期时间，单位毫秒，默认一天</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">paths</span>: <span class="string">&#x27;auto&#x27;</span>, <span class="comment">// or &#x27;auto&#x27;</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">placeholder</span>: <span class="string">&#x27;搜索&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">noData</span>: <span class="string">&#x27;无结果&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">hideOtherSidebarContent</span>: <span class="literal">false</span>, <span class="comment">// 是否隐藏其他侧边栏内容</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">namespace</span>: <span class="string">&#x27;website-1&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">pathNamespaces</span>: [<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/config&#x27;</span>, <span class="string">&#x27;/guide&#x27;</span>]</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Docsify v4 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify/lib/plugins/search.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/docsify-count/dist/countable.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.jsdelivr.net/npm/docsify-pagination/dist/docsify-pagination.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/docsify-sidebar-collapse@1.3.5/dist/docsify-sidebar-collapse.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- code highlight --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-bash.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-csharp.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-java.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-json.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-markdown.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-nginx.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-properties.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-sql.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-xml-doc.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//unpkg.com/prismjs@1.27.0/components/prism-yaml.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="readme-md"><a href="#readme-md" class="headerlink" title="readme.md"></a>readme.md</h3><p>默认是使用 readme作为首页的</p>
<h3 id="sidebar-md"><a href="#sidebar-md" class="headerlink" title="_sidebar.md"></a>_sidebar.md</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!-- docs/<span class="emphasis">_sidebar.md --&gt;</span></span><br><span class="line"><span class="emphasis">* 首页</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">首页</span>](<span class="link">readme &quot;首页&quot;</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">指南</span>](<span class="link">guide &quot;很厉害的导航页面&quot;</span>)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">* 配置</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">配置说明</span>](<span class="link">config/config</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">配置说明1</span>](<span class="link">config/config1</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">配置说明2</span>](<span class="link">config/config2</span>)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">* 命令</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">命令1</span>](<span class="link">command/command1</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">命令2</span>](<span class="link">command/command2</span>)</span></span><br><span class="line"><span class="emphasis">	* [<span class="string">命令3</span>](<span class="link">command/command3</span>)</span></span><br><span class="line"><span class="emphasis"></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>docsify</tag>
      </tags>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/tools/git-command/</url>
    <content><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>配置可以通过gui工具进行。</li>
<li>git config –list 查看所有配置</li>
<li>git config user.name 查看用户名。</li>
</ul>
<span id="more"></span>

<ul>
<li>配置全局的用户名和邮箱<br>如果不是个人机器，可以去掉global选项，仅针对当前仓库配置。</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><strong>git init</strong> 在目录中初始化仓库，使用git管理。<br> 初始化仓库之后， 可以git remote add [shortname] [url]，添加到远程仓库中。<blockquote>
<p>git remote add cpf <a href="https://github.com/cpf929/test.git">https://github.com/cpf929/test.git</a></p>
</blockquote>
</li>
<li><strong>git clone</strong> 克隆仓库的命令格式为 <code>git clone [url]</code></li>
<li>文件跟踪和更新到仓库</li>
</ul>
<p>工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>
<p>git文件状态变化周期.</p>
<ul>
<li><p><strong>git status</strong> 查看文件状态</p>
</li>
<li><p><strong>git add</strong> 跟踪文件(把文件放入暂存区，文件处于暂存状态)<br>根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等</p>
</li>
<li><p><strong>git diff</strong><br>比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。<br>若要看已经暂存起来的文件和上次提交时的快照之间的差异，使用 <code>git diff --staged</code>。</p>
</li>
<li><p><strong>git commit</strong> 提交暂存区的文件。<br>git commit -m ‘注释’<br>git commit -a 把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤</p>
</li>
<li><p><strong>git rm [filename]</strong> 从暂存区和工作空间中移除文件。<br>git rm –cached readme.txt, 只从暂存区移除，而保留在工作空间。</p>
</li>
<li><p><strong>重命名</strong> <code>git mv from_name to_name</code><br>相当于执行了三条命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv from_name to_name</span><br><span class="line">git rm from_name</span><br><span class="line">git add to_name</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>git log</strong> 显示日志<br>git log -p -2 , <code>-p</code> 选项展开显示每次提交的内容差异，用 <code>-2</code> 则仅显示最近的两次更新</p>
</li>
</ul>
<blockquote>
<p>git log –pretty&#x3D;oneline</p>
</blockquote>
<h3 id="撤销操作-REDO-UNDO"><a href="#撤销操作-REDO-UNDO" class="headerlink" title="撤销操作 REDO&#x2F;UNDO"></a>撤销操作 REDO&#x2F;UNDO</h3><p>参考 <a href="https://github.blog/2015-06-08-how-to-undo-almost-anything-with-git/">How to undo (almost) anything with Git</a></p>
<ol>
<li>修改上次的提交的内容</li>
</ol>
<p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 <code>--amend</code> 选项重新提交.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &#x27;initial commit&#x27;</span><br><span class="line">git add forgotten_file </span><br><span class="line">git commit --amend</span><br><span class="line">or git commit --amend -m &quot;注释&quot;</span><br></pre></td></tr></table></figure>
<p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<p><code>git commit --amend</code> 会打开编辑器，可以修改上次的提交信息。</p>
<ol start="2">
<li>还原某次提交</li>
</ol>
<p>使用 <code>git revert &lt;SHA&gt;</code> 来直接还原指定的提交，会产生一次新的提交内容，将上次提交的内容删除。</p>
<ol start="3">
<li>撤销工作区中未提交的内容</li>
</ol>
<p><code>git checkout --filename </code> ，撤销工作区文件的修改，不可逆的， 无法通过git找回。</p>
<ol start="4">
<li>重置本地的提交<br>reset到指定的提交版本，丢弃后面产生的提交信息。reset 之后，在git log中没有丢弃后的那些错误的提交记录。</li>
</ol>
<ul>
<li>使用 <code>git reset &lt;last good SHA&gt;</code> or <code>git reset --hard &lt;last good SHA&gt;</code></li>
</ul>
<ol start="5">
<li>Redo after undo “local”</li>
</ol>
<p>reset之后，又想要把对应的提交还原回来。<br>使用 <code>git reflog</code> and <code>git reset</code></p>
<p>reflog 记录有时限，且只在本地才有。</p>
<p>如果想重新创建某个文件，使用 <code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code></p>
<p>如果只想要把某次的提交内容合并到本地，使用 <code>git cherry-pick &lt;SHA&gt;</code></p>
<h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><ul>
<li>查看远程仓库<br>git remote -v ，查看远程仓库和克隆的地址</li>
<li>添加远程仓库<br>git remote add [shortname] [url]<br>现在可以用[shortname]代替远程地址。如： git fetch [shortname]</li>
<li>从远程仓库抓取数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch [remote-name]</span><br></pre></td></tr></table></figure>
会到远程仓库中拉取所有你本地仓库中还没有的数据或更新，只是拉取数据，但是并不自动合并到当前工作分支，</li>
<li>推送数据到远程仓库<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure>
克隆操作会自动使用默认的 master 和 origin 名字,所以可以直接git push</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo-next主题配置方式</title>
    <url>/tools/hexo-next-theme/</url>
    <content><![CDATA[<p>主要介绍hexo的配置，和使用next主题时的一些自定义配置，需要先确认版本是否一致。<br>本文主要基于 hexo 7.0.0 和 next 8.18.2，如果版本不一致，可能会有报错。</p>
<span id="more"></span>


<h2 id="hexo安装配置"><a href="#hexo安装配置" class="headerlink" title="hexo安装配置"></a>hexo安装配置</h2><p>操作比较简单，可以直接参考官方文档  <a href="https://hexo.io/zh-cn/docs/configuration">hexo配置</a></p>
<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>版本依赖</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">$</span> <span class="string">npm list</span></span><br><span class="line"><span class="attr">hexo-site@0.0.0</span> <span class="string">D:\Documents\GitHub\hexo</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">@waline/hexo-next@3.0.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-cli@4.3.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-deployer-git@4.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-archive@2.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-category@2.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-index@3.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-searchdb@1.4.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-generator-tag@2.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-renderer-ejs@2.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-renderer-marked@6.1.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-renderer-stylus@3.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-server@3.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-symbols-count-time@0.7.1</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-theme-landscape@1.0.0</span></span><br><span class="line"><span class="attr">├──</span> <span class="string">hexo-theme-next@8.18.2</span></span><br><span class="line"><span class="attr">└──</span> <span class="string">hexo@7.0.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h3><ol>
<li>先检查hexo版本， hexo version ，如果不对，可以 <code>npm install -g hexo-cli</code> 全局升级。然后再次查看版本是否升级成功</li>
<li>使用npm-check，检查项目依赖的插件是否需要升级。</li>
<li>使用npm-upgrade，升级依赖的插件。</li>
<li>npm update -g，更新全局插件。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo version</span><br><span class="line"></span><br><span class="line">npm install -g npm-check</span><br><span class="line">npm-check</span><br><span class="line"></span><br><span class="line">npm install -g npm-upgrade</span><br><span class="line">npm-upgrade</span><br><span class="line"></span><br><span class="line">npm update -g</span><br><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<h2 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h2><p>主要是修改themes&#x2F;next 文件夹内的<code>_config.yml</code> 文件里面的配置</p>
<p><a href="https://theme-next.iissnan.com/getting-started.html">参考官方文档</a></p>
<h3 id="开启阅读时长"><a href="#开启阅读时长" class="headerlink" title="开启阅读时长"></a>开启阅读时长</h3><ol>
<li>npm安装插件</li>
</ol>
<blockquote>
<p>npm install hexo-symbols-count-time -g</p>
</blockquote>
<ol start="2">
<li>修改hexo的主配置，添加</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br><span class="line">  exclude_codeblock: false</span><br><span class="line">  awl: 3</span><br><span class="line">  wpm: 200</span><br><span class="line">  suffix: &quot;mins.&quot;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查看next的配置文件中的内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置完成后，需要执行 hexo clean，否则阅读时长可能会显示 NaN</li>
</ol>
<blockquote>
<p> hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p>
</blockquote>
<h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><ol>
<li>安装插件</li>
</ol>
<blockquote>
<p>npm install hexo-generator-searchdb</p>
</blockquote>
<ol start="2">
<li>开启next的搜索配置</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">enable</span>: <span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="开启访问数统计"><a href="#开启访问数统计" class="headerlink" title="开启访问数统计"></a>开启访问数统计</h3><p>开启配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="添加评论系统"><a href="#添加评论系统" class="headerlink" title="添加评论系统"></a>添加评论系统</h3><p>经过网上的查询和综合评估，选择了<a href="https://waline.js.org/guide/get-started/">waline</a> 作为评论系统。</p>
<ol>
<li><p>首先需要注册和部署相关应用， 可以直接参考官方文档 <a href="https://waline.js.org/guide/get-started/">waline get-started</a></p>
</li>
<li><p>由于 Next 主题中没有 Waline 的评论配置，需要安装官方的插件，在目录下执行</p>
</li>
</ol>
<blockquote>
<p>npm install @waline&#x2F;hexo-next</p>
</blockquote>
<ol start="3">
<li>在next主题的配置下面添加, 一定要修改 serverURL 为自己的</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Waline</span></span><br><span class="line"><span class="comment"># For more information: https://waline.js.org, https://github.com/walinejs/waline</span></span><br><span class="line"><span class="attr">waline:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#是否开启</span></span><br><span class="line">  <span class="attr">serverURL:</span> <span class="string">填写第一步部署后获取到的地址</span> <span class="comment"># Waline #服务端地址，我们这里就是上面部署的 Vercel 地址</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">请文明评论呀</span> <span class="comment"># #评论框的默认文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># 头像风格</span></span><br><span class="line">  <span class="attr">meta:</span> [<span class="string">nick</span>, <span class="string">mail</span>, <span class="string">link</span>] <span class="comment"># 自定义评论框上面的三个输入框的内容</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># 评论数量多少时显示分页</span></span><br><span class="line">  <span class="attr">lang:</span> <span class="string">zh-cn</span> <span class="comment"># 语言, 可选值: en, zh-cn</span></span><br><span class="line">  <span class="comment"># Warning: 不要同时启用 `waline.visitor` 以及 `leancloud_visitors`.</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># 文章阅读统计</span></span><br><span class="line">  <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># 如果为 false , 评论数量只会在当前评论页面显示, 主页则不显示</span></span><br><span class="line">  <span class="attr">requiredFields:</span> [] <span class="comment"># 设置用户评论时必填的信息，[nick,mail]: [nick] | [nick, mail]</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="comment"># Set custom library cdn url</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重新生成</li>
</ol>
<blockquote>
<p> hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</p>
</blockquote>
<h3 id="登录注册评论后台"><a href="#登录注册评论后台" class="headerlink" title="登录注册评论后台"></a>登录注册评论后台</h3><p>Waline 有服务端，支持评论管理。找到评论框，点击 登录 按钮，会弹出一个窗口，找到用户注册，默认第一个注册的用户为管理员，所以部署好一定要记得及时注册。</p>
<p>注册登录之后， 就可以对评论进行管理了。</p>
<h3 id="hexo开启-mermaid"><a href="#hexo开启-mermaid" class="headerlink" title="hexo开启 mermaid"></a>hexo开启 mermaid</h3><p><code>mermaid</code> 可以帮助在markdown中画流程图，时序图等</p>
<p>首先需要在项目目录下面安装依赖</p>
<blockquote>
<p> npm i hexo-filter-mermaid-diagrams</p>
</blockquote>
<p>然后在配置中开启</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>下面就可以在markdown文件中添加对应的内容，页面就会自动渲染了， 如下面的例子</p>
<p><strong>流程图</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">mermaid</span></span><br><span class="line"><span class="string">graph</span> <span class="string">TD</span></span><br><span class="line"><span class="string">Start</span> <span class="string">--&gt;</span> <span class="string">Stop</span></span><br></pre></td></tr></table></figure>


<pre class="mermaid">graph TD
Start --> Stop</pre>

<p><strong>时间轴</strong></p>
<pre class="mermaid">timeline
      title History of Social Media Platform
      2002 : LinkedIn
      2004 : Facebook
           : Google
      2005 : Youtube
      2006 : Twitter</pre>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用</title>
    <url>/tools/hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br><span class="line"></span><br><span class="line"> hexo new post -p folder/fileanme <span class="string">&quot;titlename&quot;</span></span><br><span class="line"> </span><br><span class="line"> 比如 &gt;hexo new post -p tools/testfile <span class="string">&quot;测试文章&quot;</span></span><br><span class="line">  // 就是在posts 下的 tools目录中创建了文件 testfile.md，文件中对应的title是 测试文章</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
<h3 id="使用图片"><a href="#使用图片" class="headerlink" title="使用图片"></a>使用图片</h3><p>可以将图片放到 source&#x2F;images 目录下面即可，然后在文章中使用markdown语法访问他们, 参考 <a href="https://fuhailin.github.io/Hexo-images/">资源文件夹</a></p>
<blockquote>
<p> <code>![](/images/image.jpg)</code></p>
</blockquote>
<p>效果如下:</p>
<p><img data-src="/images/assets/40703300-d32f-11ea-938e-f5ee97dc461f.jpg"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用jsdelivr加速hexo github pages博客的静态资源</title>
    <url>/tools/use-jsdelivr-cdn-hexo-blog/</url>
    <content><![CDATA[<p>使用hexo将博客部署在github pages上面，有时候访问速度会比较慢，可以将图片等静态资源，使用jsdelivr进行cdn加速。</p>
<p>目前由于一些非法的滥用，jsdelivr在国内被墙，无法访问了。</p>
<span id="more"></span>

<h3 id="使用介绍"><a href="#使用介绍" class="headerlink" title="使用介绍"></a>使用介绍</h3><p><a href="https://github.com/jsdelivr/jsdelivr?tab=readme-ov-file#github">jsdelivr加速github介绍</a></p>
<p>根路径是 :  <a href="https://cdn.jsdelivr.net/">https://cdn.jsdelivr.net</a></p>
<h4 id="Load-any-GitHub-release-commit-or-branch"><a href="#Load-any-GitHub-release-commit-or-branch" class="headerlink" title="Load any GitHub release, commit, or branch:"></a>Load any GitHub release, commit, or branch:</h4><blockquote>
<p>&#x2F;gh&#x2F;user&#x2F;repo@version&#x2F;file</p>
</blockquote>
<h4 id="Load-exact-version"><a href="#Load-exact-version" class="headerlink" title="Load exact version:"></a>Load exact version:</h4><blockquote>
<p>&#x2F;gh&#x2F;jquery&#x2F;<a href="mailto:&#x6a;&#113;&#x75;&#x65;&#114;&#x79;&#x40;&#51;&#46;&#x31;&#x2e;&#x30;">&#x6a;&#113;&#x75;&#x65;&#114;&#x79;&#x40;&#51;&#46;&#x31;&#x2e;&#x30;</a>&#x2F;dist&#x2F;jquery.min.js<br>&#x2F;gh&#x2F;jquery&#x2F;jquery@32b00373b3f42e5cdcb709df53f3b08b7184a944&#x2F;dist&#x2F;jquery.min.js</p>
</blockquote>
<h4 id="Use-a-version-range-instead-of-an-exact-version-only-works-with-valid-semver-versions"><a href="#Use-a-version-range-instead-of-an-exact-version-only-works-with-valid-semver-versions" class="headerlink" title="Use a version range instead of an exact version (only works with valid semver versions):"></a>Use a version range instead of an exact version (only works with valid semver versions):</h4><blockquote>
<p>&#x2F;gh&#x2F;jquery&#x2F;jquery@3&#x2F;dist&#x2F;jquery.min.js<br>&#x2F;gh&#x2F;jquery&#x2F;<a href="mailto:&#106;&#x71;&#x75;&#x65;&#114;&#121;&#64;&#51;&#46;&#x31;">&#106;&#x71;&#x75;&#x65;&#114;&#121;&#64;&#51;&#46;&#x31;</a>&#x2F;dist&#x2F;jquery.min.js</p>
</blockquote>
<ul>
<li>访问方式</li>
</ul>
<p><a href="https://cdn.jsdelivr.net/gh/Github%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D/%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84">https://cdn.jsdelivr.net/gh/Github用户名/仓库名/资源路径</a></p>
<p>默认访问 <code>master</code>分支下面的文件。</p>
<p>比如: </p>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a> 访问的是master下的</li>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.1.0/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.1.0/dist/jquery.min.js</a> 访问的是精确的版本</li>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.1/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.1/dist/jquery.min.js</a>  访问的是范围版本</li>
</ul>
<p>加速静态资源的方式， 可以在github上创建一个仓库，比如叫cdn，然后将静态资源放到方库中。</p>
<blockquote>
<p><a href="https://cdn.jsdelivr.net/gh/cpfo/cdn/images/2024/40703300-d32f-11ea-938e-f5ee97dc461f.jpg">https://cdn.jsdelivr.net/gh/cpfo/cdn/images/2024/40703300-d32f-11ea-938e-f5ee97dc461f.jpg</a></p>
</blockquote>
<p>使用加速后的图片</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/cpfo/cdn/images/2024/40703300-d32f-11ea-938e-f5ee97dc461f.jpg"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>jsdelivr</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用操作</title>
    <url>/yunwei/linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>主要记录一些日常用到的shell命令操作。</p>
<span id="more"></span>

<ol>
<li>jenkins执行remote主机上面的sh脚本时， 无法拿到远程主机的环境变量。</li>
</ol>
<p>解决方法：在文件开头的注释加上 –login</p>
<p><code> #!/bin/bash --login</code></p>
<p><a href="http://feihu.me/blog/2014/env-problem-when-ssh-executing-command-on-remote/">参考</a></p>
<ol start="2">
<li>sed 替换文件中的内容</li>
</ol>
<blockquote>
<p>sed -i ‘s&#x2F;java -jar&#x2F;$JAVA_HOME/bin/java -jar&#x2F;g’ <code>find /opt/xxxxx/ -name &quot;xxx.sh&quot;</code></p>
</blockquote>
<ol start="3">
<li>jenkins shell重启本地tomcat， 无效， 原因，jenkins 会杀死衍生进程</li>
</ol>
<p><a href="https://wiki.jenkins-ci.org/display/JENKINS/ProcessTreeKiller">参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sleep 5</span><br><span class="line">BUILD_ID=dontKillMe</span><br><span class="line">bash /opt/xxxx/business_restart.sh</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>CentOS&#x2F;RHEL 修改主机名</li>
</ol>
<ul>
<li>查看主机名</li>
</ul>
<blockquote>
<p>hostnamectl status</p>
</blockquote>
<ul>
<li>修改</li>
</ul>
<blockquote>
<p>hostnamectl –static set-hostname 名字</p>
</blockquote>
<ol start="5">
<li>创建组， 用户权限</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd dev</span><br><span class="line">useradd -g dev cpf</span><br><span class="line">passwd cpf</span><br><span class="line">用户列表文件：/etc/passwd</span><br><span class="line"></span><br><span class="line">用户组列表文件：/etc/group</span><br><span class="line"></span><br><span class="line">查看系统中有哪些用户：cut -d : -f 1 /etc/passwd</span><br><span class="line"></span><br><span class="line">查看可以登录系统的用户：cat /etc/passwd | grep -v /sbin/nologin | cut -d : -f 1</span><br><span class="line"></span><br><span class="line">查看用户操作：w命令(需要root权限)</span><br><span class="line"></span><br><span class="line">查看某一用户：w 用户名</span><br><span class="line"></span><br><span class="line">查看登录用户：who</span><br><span class="line"></span><br><span class="line">查看用户登录历史记录：last</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>修改目录所属用户和组</li>
</ol>
<blockquote>
<p>chown -R cpf.dev tomcat2&#x2F;</p>
</blockquote>
<ol start="7">
<li>磁盘</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看 fdisk –l</span><br><span class="line">fdisk /dev/vdb</span><br><span class="line">输入n 进行分区, 分区类型选 p， 分区个数默认， 柱面默认， 输入w 写入分区表</span><br><span class="line">格式化分区,如果创建的是主分区；</span><br><span class="line">mkfs -t ext3 /dev/vdb1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>find中 -mtime 中的参数n</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . –mtime n中的n指的是24*n, +n、-n、n分别表示：</span><br><span class="line">+n： 大于n</span><br><span class="line">-n:  小于n</span><br><span class="line">n：  等于n</span><br><span class="line"></span><br><span class="line">但是man find里这样的解释还是比较令人费解的，不如直接看find . -mtime 中的用法</span><br><span class="line"></span><br><span class="line">find . –mtime n:  File waslast modified n*24 hours ago.</span><br><span class="line"></span><br><span class="line">最后一次修改发生在距离当前时间n*24小时至(n+1)*24 小时</span><br><span class="line"></span><br><span class="line">find . –mtime +n:</span><br><span class="line"></span><br><span class="line">最后一次修改发生在n+1天以前，距离当前时间为(n+1)*24小时或者更早</span><br><span class="line"></span><br><span class="line">find . –mtime –n:</span><br><span class="line"></span><br><span class="line">最后一次修改发生在n天以内，距离当前时间为n*24小时以内</span><br></pre></td></tr></table></figure>



<ol start="9">
<li>awk</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk默认分割符是空格或制表符。</span><br><span class="line">cut命令不能在分割符是空格的字符串中截取列，只能是制表符或具体的分割符。</span><br><span class="line">cut [选项] 文件</span><br><span class="line">awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125; ...&#x27; 文件名</span><br><span class="line"></span><br><span class="line">awk &#x27;&#123;print $1&#125;&#x27; 文件名</span><br><span class="line">awk &#x27;&#123;if ( $1 &gt; 10 )&#123; print $1&#125; &#125;&#x27;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>网络监控工具</li>
</ol>
<p>iftop,  iptraf-ng</p>
<ol start="11">
<li>root 删除文件 Operation not permitted</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsattr 1.txt</span><br><span class="line">——i—— 1.txt</span><br><span class="line">在lsattr命令下，这个1.txt文件带有一个&quot;i&quot;的属性，所以才不可以删除</span><br><span class="line">chattr -i 1.txt</span><br><span class="line"></span><br><span class="line">chattr +i filename 加上保护</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>获取目录， 文件名</li>
</ol>
<blockquote>
<p>dirname, basename</p>
</blockquote>
<ol start="13">
<li>redis批量更新</li>
</ol>
<blockquote>
<p>for i in $(cat news1.txt) ; do echo ‘set’ $i $((RANDOM % (200 - 50) + 50)); done | redis-cli -c -p 6300</p>
</blockquote>
<ol start="14">
<li>nginx统计</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx按分钟统计访问频率高的</span><br><span class="line">awk &#x27;&#123;print $3&#125;&#x27; access.log | cut -c 14-18 | uniq -c  | sort -rn  | head -n 100</span><br><span class="line"></span><br><span class="line">统计耗时的请求</span><br><span class="line">tail -200000 access.log | awk  &#x27;&#123;print $3, $6 ,$10&#125;&#x27; | sort -k3 -rn | head -100</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>切割大文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -3000000 4.txt &gt; 4.1.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -n +3000001 4.txt &gt; 4.2.txt</span></span><br><span class="line"></span><br><span class="line">split -l 2600000 -d imei-part-3.txt  imei-part-3_</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="16">
<li>循环请求url</li>
</ol>
<blockquote>
<p>for i in <code>cat udid.txt</code> ; do curl  -0 $i; echo ‘’ ; done</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx拦截非法host的请求</title>
    <url>/yunwei/nginx-deny-host/</url>
    <content><![CDATA[<p>在nginx的访问日志中发现了一些奇怪的host域名，并非是实际用到的，经过排查发现，可以在本地的hosts文件中指定ip和域名的映射关系， 这样就可以通过访问一个任意的域名，来请求到对应的ip地址上面，因为nginx会使用默认server来处理未匹配到server_name的请求，可以通过这种方式来绕过waf等，或者访问到nginx中其他的servername下， 会有一定的风险，需要将这种方式拦截掉</p>
<span id="more"></span>

<p>比如在hosts文件中指定ip对应 <a href="http://www.abc.com/">www.abc.com</a> </p>
<blockquote>
<p>xx.xx.xx.xx <a href="http://www.abc.com/">www.abc.com</a></p>
</blockquote>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>因为nginx默认按照ASCII码的顺序来加载conf配置文件，所以可以通过创建一个00开头的conf文件，来保证是最先加载的，在该文件中指定默认的server_name,<br>来拦截所有的非法host的请求</p>
<p>可以使用 <code>ls -nl</code> 来查看nginx conf文件的ASCII顺序。</p>
<p>00block.conf 文件的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">	listen 80 default_server;</span><br><span class="line">        server_name __;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">		deny all;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen 443 ssl default_server;</span><br><span class="line">        server_name _;</span><br><span class="line">        ssl_certificate cert/xxx.com.pem;</span><br><span class="line">        ssl_certificate_key cert/xxx.com.key;</span><br><span class="line">        ssl_session_timeout 5m;</span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; </span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                deny all;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这样就可以禁止掉直接通过IP或者本地绑定域名的方式的非法请求。</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
